[
  {
    "objectID": "acknowledgments.html",
    "href": "acknowledgments.html",
    "title": "Acknowledgments",
    "section": "",
    "text": "Contributors\n\n\nFunding"
  },
  {
    "objectID": "applications/EIA.html",
    "href": "applications/EIA.html",
    "title": "Environmental Impact Assessment",
    "section": "",
    "text": "Environmental Impact Assessment – EIA\n\n\n\n\n\n\nNote\n\n\n\nAssessment of impact of anthropogenic infrastructures for wild reindeer habitat loss and fragmentation.\n\n\nDorber et al. 2023 presents a first application of functional habitat to the assessment of the impact of hydropower on wild reindeer in Norway.\nGo here for an application of ConScape for reindeer habitat assessments, including interactive web maps in the Google Earth Engine:\n\nWild reindeer maps: where you can explore maps produced using analytical approaches to illustrate how reindeer view the landscape in terms of suitable resources, functional areas, corridors, barriers, and human footprint,\nComparison with expert-based maps: where you can compare maps produced using analytical approaches (using also ConScape) to maps produced through expert assessment for the Norwegian Wild Reindeer Quality Norm assessment - Delnorm 3."
  },
  {
    "objectID": "applications/GI.html",
    "href": "applications/GI.html",
    "title": "Green infrastructure mapping",
    "section": "",
    "text": "Go here for an application of ConScape for green infrastructure mapping, including interactive web maps in the Google Earth Engine:\n\nSpecies-specific ecological networks: where you can view landscapes from a species perspective using the Ecological Network Mapping Tool,\nComparison with pixel-based maps: where you can compare traditional, pixel-focussed maps to green infrastructure, network-based maps,\nGI prioritization: where you can identify priority areas for multi-species conservation using the Land Prioritization Tool."
  },
  {
    "objectID": "applications/index.html",
    "href": "applications/index.html",
    "title": "Applications",
    "section": "",
    "text": "Applications of ConScape\nConScape is being used for different ecological applications from cumulative impact assessment, spatial conservation prioritization, to green infrastructure mapping for biodiversity conservation.\n\nclick Assessment of impact of anthropogenic infrastructures for wild reindeer habitat loss and fragmentation,\nclick Green infrastructure mapping for biodiversity conservation,"
  },
  {
    "objectID": "background.html",
    "href": "background.html",
    "title": "Background",
    "section": "",
    "text": "Panzacchi et al. 2015 shows the first application of the randomized shortest paths framework in combination with step selection functions.\nVan Moorter et al. 2021 presents a framework to scale up step selection functions to assess effective connectivity using the randomized shortest paths framework. This paper presents an extensive discussion of the RSP in an ecological context.\nVan Moorter et al. 2023 is the core publication of the ConScape library, and should be cited for the library.\nVan Moorter et al. 2023 is the main publication describing the concept of functional habitat, i.e. habitat that is simultaneously suitable and well-connected to other suitable habitat. It is the computation of this quantity that motivated the development of the ConScape library.\nDorber et al. 2023 presents a first application of functional habitat to the assessment of the impact of hydropower on wild reindeer in Norway."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "ConScape goes live\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\nBram van Moorter\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "faq/2022_where_are_the_test_data/index.html",
    "href": "faq/2022_where_are_the_test_data/index.html",
    "title": "Where can I find the test data for the notebooks?",
    "section": "",
    "text": "Here in the github repository of the ConScape library"
  },
  {
    "objectID": "faq/2022_which_value_for_theta/index.html",
    "href": "faq/2022_which_value_for_theta/index.html",
    "title": "Which value to choose for theta?",
    "section": "",
    "text": "In other words: “which level of randomness for the paths between source and target?”\nA difficult question… First, testing different values of \\(\\theta\\) will allow you to assess the sensitivity of your results to this crucial parameter. Furthermore, several efforts exist to estimate \\(\\theta\\) from movement data, for instance: Kivimäki et al. 2020, and Panzacchi et al. 2015."
  },
  {
    "objectID": "faq/2022_why_julia/index.html",
    "href": "faq/2022_why_julia/index.html",
    "title": "Why is ConScape implemented in Julia?",
    "section": "",
    "text": "This question usually continues with “instead of R”. There are two reasons, first, Julia is a high-performance language that combines the performance of C with the readability of a language like R. For instance, all libraries in R that do performance critical computations, such as the “spatial absorbing Markov chain” library, are wrappers around C code. This introduces what has been called the provlem of “two languages”, i.e. that one has to master two languages (in this case R and C) to use the library in a flexible way or contribute to its further development. As a side note, while the preformance benchmark, C is not a very easy language to read or write. Here comes in Julia, it has a performance very close to C, but the readability of R. It is therefore relatively easy for someone with some programming background (as any intermediate to advanced R user) to use the library in a flexible way and hopefully also contribute to its further development. A second reason was that Julia was also adopted by Circuitscape for its latest implementation, which will facilitate collaboration and community contributions from a broader group of landscape connectivity modelers.\nAs we do appreciate the challenge associated with working in a new programming language, we did develop a large set of notebooks to serve as templates to modify for your own purposes. Indeed, our own experience with using Julia and ConScape did rely adjusting existing code at first. Hence, we encourage you to give it a try, it is by no means as daunting as it may seem (to get started)."
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Why is ConScape implemented in Julia?\nThis question usually continues with “instead of R”. There are two reasons, first, Julia is a high-performance language that combines the performance of C with the readability of a language like R. For instance, all libraries in R that do performance critical computations, such as the “spatial absorbing Markov chain” library, are wrappers around C code. This introduces what has been called the provlem of “two languages”, i.e. that one has to master two languages (in this case R and C) to use the library in a flexible way or contribute to its further development. As a side note, while the preformance benchmark, C is not a very easy language to read or write. Here comes in Julia, it has a performance very close to C, but the readability of R. It is therefore relatively easy for someone with some programming background (as any intermediate to advanced R user) to use the library in a flexible way and hopefully also contribute to its further development. A second reason was that Julia was also adopted by Circuitscape for its latest implementation, which will facilitate collaboration and community contributions from a broader group of landscape connectivity modelers.\nAs we do appreciate the challenge associated with working in a new programming language, we did develop a large set of notebooks to serve as templates to modify for your own purposes. Indeed, our own experience with using Julia and ConScape did rely adjusting existing code at first. Hence, we encourage you to give it a try, it is by no means as daunting as it may seem (to get started).\n\n\nWhich value to choose for theta (\\(\\theta\\))?\nIn other words: “which level of randomness for the paths between source and target?”\nA difficult question… First, testing different values of \\(\\theta\\) will allow you to assess the sensitivity of your results to this crucial parameter. Furthermore, several efforts exist to estimate \\(\\theta\\) from movement data, for instance: Kivimäki et al. 2020, and Panzacchi et al. 2015.\n\n\nWhere can I find the test data for the notebooks?\nHere in the github repository of the ConScape library\n\n\nI am getting empty plots\n\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= NaN\nhab_qual[non_matches] .= NaN;\n\n\n\nCan I use a patch-matrix landscape representation in ConScape\nYes, but we still have to make a notebook to demonstrate this application."
  },
  {
    "objectID": "faqV2.html",
    "href": "faqV2.html",
    "title": "FAQ",
    "section": "",
    "text": "I am trying a second approach to for the Frequently Asked Questions based on the Quarto listing for blogs. Thus, FAQs are treated much like blog posts.\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nDec 5, 2022\n\n\nWhere can I find the test data for the notebooks?\n\n\nBram van Moorter\n\n\n\n\nDec 5, 2022\n\n\nWhich value to choose for theta?\n\n\nBram van Moorter\n\n\n\n\nDec 5, 2022\n\n\nWhy is ConScape implemented in Julia?\n\n\nBram van Moorter\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "glossary.html",
    "href": "glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Quality of habitat\nThe quality of habitat refers to the contribution of the local environmental conditions to a population in terms of fitness.\n\n\nPermeability of habitat\nThe permeability of habitat for movement refers to the effect of local environmental conditions on: (1) the likelihood of movement, and (2) the cost of movement. See for Fletcher et al. 2019 and Van Moorter et al. 2021 for further discussion.\n\n\nResource selection function\nSee Boyce and McDonald 1999\n\n\nStep selection function\nSee Fortin et al. 2005"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Warning\n\n\n\nThe site is under active development, this is for testing purposes only!\n\n\n\nWelcome\nConScape (i.e. “connected landscapes”) is a software library implemented in the high-performance open-source Julia language to compute landscape ecological metrics — originally developed in metapopulation ecology (such as ‘metapopulation capacity’ and ‘probability of connectivity’) — for large landscapes. Moreover,in addition to traditional distance metrics used in ecology (i.e. Euclidean and least-cost distance), ConScape implements the randomized shortest paths framework to represent connectivity along the continuum from optimal to random movements.\nBuilt by a team of ecologists, network scientists and software developers, ConScape is able to efficiently compute landscape metrics for high-resolution landscape representations to leverage the availability of large data for sustainable land use and biodiversity conservation. As a Julia implementation, ConScape combines computational efficiency with a transparent code base, which facilitates continued innovation through contributions from the rapidly growing community of landscape and connectivity modellers using Julia.\n\n\n\n\n\n\nConScape citation\n\n\n\n\nAPA stylebibtex\n\n\nVan Moorter, B., Kivimäki, I., Noack, A., Devooght, R., Panzacchi, M., Hall, K. R., Leleux, P. & Saerens, M. (2023). Accelerating advances in landscape connectivity modelling with the ConScape library. Methods in Ecology and Evolution, 14(1), 133–145.\n\n\n@article{vanmoorter2023accelerating,\n  author = {Van Moorter, Bram and Kivimäki, Ilkka and Noack, Andreas and Devooght, Robin and Panzacchi, Manuela and Hall, Kimberly R. and Leleux, Pierre and Saerens, Marco},title = {Accelerating advances in landscape connectivity modelling with the ConScape library},\n  journal = {Methods in Ecology and Evolution},\n  volume = {14},\n  number = {1},\n  pages = {133-145},\n  doi = {https://doi.org/10.1111/2041-210X.13850},\n  url = {https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.13850},\n  eprint = {https://besjournals.onlinelibrary.wiley.com/doi/pdf/10.1111/2041-210X.13850},\n  year = {2023}\n}\n\n\n\n\n\n\n\nConScape’s origin story\nConScape was developed to integrate habitat suitability with habitat permeability, as measured by respectively resource and step selection functions, for wild reindeer in Norway. To this end we rediscovered the Conefor approach, which we extended with the randomized shortest paths (RSP) framework instead of the least-cost path one. This RSP framework is itself an extension of the pure random walk, as in Circuitscape. The name ConScape itself refers not only to ‘Connected Landscapes’, but also to Conefor + Circuitscape as a testimony to this legacy.\nConScape has a similar focus as Conefor in that it aims at assessing the landscape network as a whole, i.e. it connects all landscape units (e.g. pixels) to each other (in other words, all-to-all connectivity). However, ConScape uses the RSP framework in addition to the LCP to compute the connectivity. Circuitscape, on the other hand, is a pioneering connectivity tool to move beyond an exclusive focus on the least-cost path connecting two points to considering all paths following a random walk process (based on the movement of electricity on an electrical network). However, Circuitscape’s main use case is not focussed on an all-to-all connectivity assessment, but instead aims at identifying corridors between a limited number of areas.\n\n\nHow the documentation is organized\nWe are developing the documentation for ConScape following the four types of documentation system, note that this is very much under development and not all types are equally present. However, an overview of these four types may be helpful for you to know where to look for certain things:\n\nTutorials take you by the hand through a series of steps to run your first analysis using ConScape. Start here if you’re new to ConScape or connectivity analysis, for instance with the getting started notebook. Also look at the Quick Start.\n‘How-to guides’ are recipes. They guide you through the steps involved in addressing key problems and use-cases. They are more advanced than tutorials and assume some knowledge of how ConScape works. These can be found under specific Frequently Asked Questions.\n‘Topic guides’ discuss key topics and concepts in ConScape and connectivity modeling in general at a fairly high level and provide useful background information and explanation. These can be found under Background or specific Frequently Asked Questions\n‘Reference guides’ contain technical reference for APIs and other aspects of ConScape’s machinery. They describe how it works and how to use it but assume that you have a basic understanding of key concepts."
  },
  {
    "objectID": "notebooks/index.html",
    "href": "notebooks/index.html",
    "title": "Notebooks",
    "section": "",
    "text": "Here I will present an annotated index of the different notebooks through a short summary.\nThe first Notebook on how getting started with ConScape is a prerequisite for all subsequent Notebooks.\nFrom here we recommend you look at the Notebook on performance as this introduces the concept of ‘landmarks’, which are used throughout the other Notebooks to improve performance.\nThe next Notebook on different ecological distance metrics builds upon the ideas presented in (Moorter et al. 2021).\nThe next Notebook details different ways to measure functional habitat.\nFinally, the Notebook on dispersal mortality uses the ConScape library for applications similar to those presented in (Fletcher Jr et al. 2019) and (Moorter et al. 2021), where the probability and cost of movement are potentially independent processes.\nnumerical issues\n\n\n\n\nReferences\n\nFletcher Jr, Robert J, Jorge A Sefair, Chao Wang, Caroline L Poli, Thomas AH Smith, Emilio M Bruna, Robert D Holt, Michael Barfield, Andrew J Marx, and Miguel A Acevedo. 2019. “Towards a Unified Framework for Connectivity That Disentangles Movement and Mortality in Space and Time.” Ecology Letters 22 (10): 1680–89.\n\n\nMoorter, Bram van, Ilkka Kivimäki, Manuela Panzacchi, and Marco Saerens. 2021. “Defining and Quantifying Effective Connectivity of Landscapes for Species’ Movements.” Ecography 44 (6): 870–84."
  },
  {
    "objectID": "notebooks/nbk_cost.html",
    "href": "notebooks/nbk_cost.html",
    "title": "Dispersal mortality",
    "section": "",
    "text": "Here you will learn\n\n\n\nIn this notebook, we demonstrate the possibility to use independent movement probablities and costs, similar to (Fletcher Jr et al. 2019) and (Marx et al. 2020)."
  },
  {
    "objectID": "notebooks/nbk_cost.html#preamble",
    "href": "notebooks/nbk_cost.html#preamble",
    "title": "Dispersal mortality",
    "section": "Preamble",
    "text": "Preamble\nSee notebook Getting Started for a ‘basic workflow’ to learn about the fundamentals on data import and the creation of a ConScape Grid:\n\n#using Pkg\n#Pkg.activate(joinpath(ENV[\"HOME\"], \".julia\", \"dev\", \"ConScape\"))\n\nusing ConScape\nusing SparseArrays\nusing Statistics\nusing Plots\n\n\ndatadir = joinpath(ENV[\"HOME\"], \"Downloads\", \"input_maps\")\noutdir = joinpath(ENV[\"TMPDIR\"], \"figures\")\nif !isdir(outdir)\n    mkdir(outdir)\nend\n\n\n\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n\n\nWe use the data provided in (Marx et al. 2020):\n\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \n            \"prob_panther_cropped.asc\"))\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \n            \"prob_panther_cropped.asc\"))\n\n([0.111111111938953 0.5 … 0.111111111938953 0.16666667163372; 0.125 0.125 … 0.111111111938953 0.16666667163372; … ; NaN NaN … 1.0 0.111111111938953; NaN NaN … 1.0 0.333333343267441], Dict{Any, Any}(\"cellsize\" => 500.0, \"nrows\" => 99, \"nodata_value\" => -999, \"ncols\" => 174, \"xllcorner\" => 615138.0, \"yllcorner\" => 257108.0))\n\n\nNote, we did not have quality data for each pixel, for this demonstration we simply assumed that the permeability adequately represents quality (see Notebook Getting Started for a better example with independent quality data).\nWe remove negative values:\n\nmov_prob = max.(0, mov_prob)\nhab_qual = max.(0, hab_qual);"
  },
  {
    "objectID": "notebooks/nbk_cost.html#cost-data",
    "href": "notebooks/nbk_cost.html#cost-data",
    "title": "Dispersal mortality",
    "section": "Cost data",
    "text": "Cost data\nIn addition to the data on the habitat quality and the likelihood of movement, we also have independent data on the cost of movement ((Marx et al. 2020)):\n\nmov_cost, meta_c = ConScape.readasc(joinpath(datadir, \n            \"mort_panther_cropped.asc\"))\nmov_cost = max.(0, mov_cost);\n\nAs discussed in vanmoorter2021defining, to use the mortality risk as a cost in the RSP framework, we need to define the cost as the negative logarithm of the survival probability between adjacent pixels:\n\nmov_cost = -log.(1 .- mov_cost);\n\nWe create the Grid by using these cost data, instead of a transformation from the likelihood of movement:\n\ng = ConScape.Grid(size(mov_prob)...,\n    affinities=ConScape.graph_matrix_from_raster(mov_prob),\n    qualities=hab_qual,\n    costs=ConScape.graph_matrix_from_raster(mov_cost));\n\n┌ Info: cost graph contains 15 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 14 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\nTo visualize the movement costs, we define the following function, similar to the plot_indegrees function we used earlier (see Notebook Getting Started):\n\nfunction plot_incost(g; kwargs...)\n    values = sum(g.costmatrix, dims=1)\n    canvas = zeros(g.nrows, g.ncols)\n    for (i,v) in enumerate(values)\n        canvas[g.id_to_grid_coordinate_list[i]] = v\n    end\n    heatmap(canvas, yflip=true, axis=nothing, border=:none; kwargs...)\nend\n\nplot_incost (generic function with 1 method)\n\n\n\nplot_incost(g, title=\"Mortality risk\")"
  },
  {
    "objectID": "notebooks/nbk_cost.html#computing-the-survival-probability",
    "href": "notebooks/nbk_cost.html#computing-the-survival-probability",
    "title": "Dispersal mortality",
    "section": "Computing the survival probability",
    "text": "Computing the survival probability\nNow we can compute the GridRSP:\n\nh = ConScape.GridRSP(g, θ=1.0);\n\nNote that to compute the survival probability from \\(s\\) to \\(t\\) corresponding to the mortality cost associated to edges \\((i,j)\\), we need to set \\(\\theta=1.0\\) ((Moorter et al. 2021)).\nThe survival probability from all source pixels to a target pixel (e.g. 15000) is:\n\ntmp = zeros(17212)\ntmp[15000] = 1\n\ndisplay(ConScape.plot_values(g, tmp, title=\"Target\"))\n\nsurv = ConScape.survival_probability(h);\ndisplay(ConScape.plot_values(g, map(t -> t==1 ? NaN : t,  surv[:,15000]), title=\"Survival probability\"))\n\n\n\n\n\n\na\n\n\n\n\n\n\n\nb\n\n\n\n\n\n\nSurvival probability to a target.\n\n\n\n\nFinally, we can use these survival probabilities to compute for each pixel the amount of habitat it is functionally connected to:\n\nfunc = ConScape.connected_habitat(h, \n            connectivity_function=ConScape.survival_probability);\nConScape.heatmap(Array(func), yflip=true, title=\"Functional habitat\")\n\n\n\n\nAmount of connected habitat based on survival connectivity."
  },
  {
    "objectID": "notebooks/nbk_cost.html#summary",
    "href": "notebooks/nbk_cost.html#summary",
    "title": "Dispersal mortality",
    "section": "Summary",
    "text": "Summary\nThe ConScape library allows users to define the cost of movement between adjacent pixels both as a transformation from the likelihood of movement, but also from independent cost data. This application is very useful to model dispersal with mortality ((Fletcher Jr et al. 2019)), but could also be applied in combination with ‘energy landscapes’ discussed in: (Moorter et al. 2021)."
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html",
    "href": "notebooks/nbk_distance_metrics.html",
    "title": "Ecological distance",
    "section": "",
    "text": "Here you will learn\n\n\n\nDifferent ecological distance and proximity metrics implemented in ConScape."
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html#data-import-grid-and-gridrsp-creation",
    "href": "notebooks/nbk_distance_metrics.html#data-import-grid-and-gridrsp-creation",
    "title": "Ecological distance",
    "section": "Data import, Grid and GridRSP creation",
    "text": "Data import, Grid and GridRSP creation\nSee notebook Getting Started for a ‘basic workflow’ to learn about the fundamentals on data import and the creation of a ConScape Grid:\n\n#using Pkg\n#Pkg.activate(joinpath(ENV[\"HOME\"], \".julia\", \"dev\", \"ConScape\"))\n\nusing ConScape\nusing SparseArrays\nusing Statistics\nusing Plots\n\n\ndatadir = joinpath(ENV[\"HOME\"], \"Downloads\", \"input_maps\")\noutdir = joinpath(ENV[\"TMPDIR\"], \"figures\")\nif !isdir(outdir)\n    mkdir(outdir)\nend\n\n\n\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n\n\n\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \"mov_prob_1000.asc\"))\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \"hab_qual_1000.asc\"))\n\n([NaN NaN … NaN NaN; NaN NaN … NaN NaN; … ; NaN NaN … NaN NaN; NaN NaN … NaN NaN], Dict{Any, Any}(\"cellsize\" => 1000.0, \"nrows\" => 87, \"nodata_value\" => -9999, \"ncols\" => 117, \"xllcorner\" => 110650.0, \"yllcorner\" => 6.89575e6))\n\n\n\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= 1e-20\nhab_qual[non_matches] .= 1e-20;\n\n\nθ = 0.001\nadjacency_matrix = ConScape.graph_matrix_from_raster(mov_prob)\ng = ConScape.Grid(size(mov_prob)...,\n    affinities=adjacency_matrix,\n    qualities=hab_qual,\n    costs=ConScape.mapnz(x -> -log(x), adjacency_matrix))\nh = ConScape.GridRSP(g, θ = θ);\n\n┌ Info: cost graph contains 4835 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n┌ Info: removing 4834 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225"
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html#euclidean-distance",
    "href": "notebooks/nbk_distance_metrics.html#euclidean-distance",
    "title": "Ecological distance",
    "section": "Euclidean distance",
    "text": "Euclidean distance\nCompute the Euclidean distance between all pairs of source and target pixels:\n\neuclid = [hypot(xy_i[1] - xy_j[1], xy_i[2] - xy_j[2]) for xy_i in\n    g.id_to_grid_coordinate_list, xy_j in g.id_to_grid_coordinate_list]\n\n5345×5345 Matrix{Float64}:\n   0.0        1.0        2.0      …  116.108    116.25     116.966\n   1.0        0.0        1.0         115.974    116.108    116.842\n   2.0        1.0        0.0         115.849    115.974    116.726\n   3.0        2.0        1.0         115.732    115.849    116.619\n   4.0        3.0        2.0         115.624    115.732    116.52\n   1.0        1.41421    2.23607  …  115.117    115.261    115.974\n   1.41421    1.0        1.41421     114.983    115.117    115.849\n   2.23607    1.41421    1.0         114.856    114.983    115.732\n   3.16228    2.23607    1.41421     114.739    114.856    115.624\n   4.12311    3.16228    2.23607     114.63     114.739    115.525\n   5.09902    4.12311    3.16228  …  114.529    114.63     115.434\n   2.23607    2.82843    3.60555     114.272    114.425    115.117\n   2.0        2.23607    2.82843     114.127    114.272    114.983\n   ⋮                              ⋱                        \n 114.756    114.586    114.425         4.47214    3.60555    5.83095\n 114.935    114.756    114.586         5.38516    4.47214    6.7082\n 114.856    114.739    114.63     …    2.23607    3.16228    2.23607\n 114.983    114.856    114.739         1.41421    2.23607    2.0\n 115.117    114.983    114.856         1.0        1.41421    2.23607\n 115.261    115.117    114.983         1.41421    1.0        2.82843\n 115.412    115.261    115.117         2.23607    1.41421    3.60555\n 115.849    115.732    115.624    …    2.0        3.0        1.41421\n 115.974    115.849    115.732         1.0        2.0        1.0\n 116.108    115.974    115.849         0.0        1.0        1.41421\n 116.25     116.108    115.974         1.0        0.0        2.23607\n 116.966    116.842    116.726         1.41421    2.23607    0.0\n\n\nThe distance from all source pixels to a given target pixel (e.g. pixel 4300):\n\ntmp = zeros(5345)\ntmp[4300] = 1\ndisplay(ConScape.plot_values(g, tmp, title=\"Target\"))\n\ndisplay(ConScape.plot_values(g, euclid[:,4300], title=\"Euclidean distance\"))\n\n\n\n\n\n\na\n\n\n\n\n\n\n\nb\n\n\n\n\n\n\nEuclidean distance to target t."
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html#least-cost-distance",
    "href": "notebooks/nbk_distance_metrics.html#least-cost-distance",
    "title": "Ecological distance",
    "section": "Least-cost distance",
    "text": "Least-cost distance\nFrom the Grid we can also compute the least-cost distances betweem \\(s\\) and \\(t\\):\n\nlcps = ConScape.least_cost_distance(g)\n\n5345×5345 Matrix{Float64}:\n   0.0      46.0517    92.1034    95.6402   …  324.669   324.322   340.565\n  46.0517    0.0       46.0517    49.5885      278.617   278.271   294.513\n  92.1034   46.0517     0.0       46.0517      275.774   275.427   291.669\n  95.6402   49.5885    46.0517     0.0         275.427   275.08    291.323\n  97.6873   51.6356    48.792     46.0517      275.33    274.983   291.226\n  46.0517   46.3983    53.9123    54.2589   …  283.288   282.941   299.183\n  46.3983   46.0517    46.3983    49.2419      278.271   277.924   294.166\n  49.2419    3.19019    2.84362    3.19019     232.219   231.872   248.115\n  51.2891    5.23737    2.39375    2.04718     229.375   229.029   245.271\n  53.5857    7.53404    4.69042    2.64324     229.278   228.932   245.174\n  99.6374   53.5857    50.7421    48.6949   …  273.38    273.033   289.276\n  50.8639   15.963     15.6164    15.963       244.992   244.645   260.888\n  49.6884   11.4973    11.1507    11.4973      240.526   240.179   256.422\n   ⋮                                        ⋱                      \n 264.586   218.534    215.69     215.344        49.5023   38.1418   66.2053\n 264.13    218.079    215.235    214.888        60.135    49.1979   76.838\n 282.906   236.854    234.011    233.664    …   26.2618   38.6569   28.6819\n 278.796   232.744    229.901    229.554        13.129    26.5877   28.4995\n 278.631   232.579    229.735    229.389        13.4586   13.8052   29.5223\n 278.271   232.219    229.375    229.029        13.7918   13.4452   30.4948\n 278.915   232.863    230.02     229.673        27.5348   14.0896   44.2379\n 294.345   248.293    245.45     245.103    …   28.6782   42.1369   15.5492\n 294.513   248.461    245.618    245.271        15.7171   29.8689   15.7171\n 294.974   248.922    246.078    245.732         0.0      16.3565   16.703\n 293.405   247.354    244.51     244.164        15.1349    0.0      31.8379\n 311.506   265.455    262.611    262.265        17.3399   33.6964    0.0\n\n\nThe least-cost distance from all source pixels to target pixel 4300 is:\n\nConScape.plot_values(g, lcps[4300,:], title=\"Least-cost distance\")\n\n\n\n\nLeast-cost distance to target t.\n\n\n\n\nNot too surprising there is a high, albeit imperfect, correlation between the Euclidean and least-cost distance:\n\ncor(euclid[:,4300], lcps[4300,:])\n\n0.9523159537210744"
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html#rsp-expected-cost-distance",
    "href": "notebooks/nbk_distance_metrics.html#rsp-expected-cost-distance",
    "title": "Ecological distance",
    "section": "RSP expected cost distance",
    "text": "RSP expected cost distance\nThe randomized shortest path (RSP) expected cost distance is the expected cost of moving from the source to the target following the RSP distribution:\n\ndists = ConScape.expected_cost(h);\n\nThe RSP expected cost from all pixels as sources to target pixel 4300:\n\nConScape.plot_values(g, dists[:,4300], title=\"RSP expected cost distance\")\n\n\n\n\nRSP expected cost distance to target t.\n\n\n\n\nComparing the least-cost distance to the RSP expected cost distance we see there is strong positive relationship:\n\ncor(lcps[:,4300], dists[:,4300])\n\n0.9413616748832977\n\n\nMost computations in ConScape require a proximity instead of a distance. A proximity is a metric from zero to one, with zero no connectivity and one perfect connectivity between a source and a target. Different transformations can be used for this, a common choice is the exponential transformation with a scaling factor (here: 1000) representing the movement capabilities of a species (see (Moorter et al. 2021) for a discussion):\n\nConScape.plot_values(g, map(x -> exp(-x/1000), dists[:,4300]), title=\"Proximity\")\n\n\n\n\nRSP expected cost proximity (logarithm) to target t."
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html#survival-probability",
    "href": "notebooks/nbk_distance_metrics.html#survival-probability",
    "title": "Ecological distance",
    "section": "Survival probability",
    "text": "Survival probability\n(Fletcher Jr et al. 2019) introduced the use of the ‘absorbing Markov chain’ or ‘killed random walk’ to connectivity modeling in landscape ecology (see also: (Moorter et al. 2021)). The RSP framework uses the same formalism and can be considered a generalization of the absorbing Markov chain in ((Fletcher Jr et al. 2019)) with the introduction of the \\(\\theta\\) paramter, see ((Moorter et al. 2021)) for discussion. Here we show ConScape’s functionality to use the survival probability from source to target as a proximtiy metric:\n\nsurv_prob = ConScape.survival_probability(h);\nConScape.plot_values(g, surv_prob[:,4300], title=\"Survival proximity\")\n\n\n\n\nSurvival proximity to target t.\n\n\n\n\nThe proximity based on the expected cost and on the survival probability show a strong positive relationship:\n\ncor(map(x -> exp(-x/1000), dists[:,4300]), surv_prob[:,4300])\n\n0.948207086404158\n\n\nFor more discussion on the use of the survival probability, in the context of the RSP framework we refer to ((Moorter et al. 2021)) and more specifically in the context of ConScape to Notebook dispersal mortality."
  },
  {
    "objectID": "notebooks/nbk_distance_metrics.html#summary",
    "href": "notebooks/nbk_distance_metrics.html#summary",
    "title": "Ecological distance",
    "section": "Summary",
    "text": "Summary\nIn ConScape different metrics are available to characterize the connectivity between source and target pixels. The metric that is most appropriate will depend upon the ecological application. (Moorter et al. 2021) suggest the use of the RSP expected cost for applications modeling individuals that move with knowledge of their landscape, whereas the survival probability is probably a more appropriate model for dispersing individuals experiencing mortality ((Fletcher Jr et al. 2019) for this last type of applications)."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html",
    "href": "notebooks/nbk_functionality_variants.html",
    "title": "Functional habitat",
    "section": "",
    "text": "Here you will learn\n\n\n\nDifferent ways to compute the amount of connected habitat for a pixel/cell or functional habitat in ConScape."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#data-import-grid-and-gridrsp-creation",
    "href": "notebooks/nbk_functionality_variants.html#data-import-grid-and-gridrsp-creation",
    "title": "Functional habitat",
    "section": "Data import, Grid and GridRSP creation",
    "text": "Data import, Grid and GridRSP creation\nSee notebook Getting Started for a ‘basic workflow’ to learn about the fundamentals on data import and the creation of a ConScape Grid:\n\n#using Pkg\n#Pkg.activate(joinpath(ENV[\"HOME\"], \".julia\", \"dev\", \"ConScape\"))\n\nusing ConScape\nusing SparseArrays\nusing Statistics\nusing Plots\n\n\ndatadir = joinpath(ENV[\"HOME\"], \"Downloads\", \"input_maps\")\noutdir = joinpath(ENV[\"TMPDIR\"], \"figures\")\nif !isdir(outdir)\n    mkdir(outdir)\nend\n\n\n\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n\n\n\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \"mov_prob_1000.asc\"))\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \"hab_qual_1000.asc\"));\n\n\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= 1e-20\nhab_qual[non_matches] .= 1e-20;\n\n\nθ = 1.0\nadjacency_matrix = ConScape.graph_matrix_from_raster(mov_prob)\ng = ConScape.Grid(size(mov_prob)...,\n    affinities=adjacency_matrix,\n    qualities=hab_qual,\n    costs=ConScape.mapnz(x -> -log(x), adjacency_matrix))\nh = ConScape.GridRSP(g, θ = θ);\n\n┌ Info: cost graph contains 4835 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n┌ Info: removing 4834 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225"
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#habitat-functionality-introduction",
    "href": "notebooks/nbk_functionality_variants.html#habitat-functionality-introduction",
    "title": "Functional habitat",
    "section": "Habitat functionality: introduction",
    "text": "Habitat functionality: introduction\nWe have defined the functionality of habitat as its suitability and its functional connectivity to suitable habitat, which has its background in metapopulation theory ((Hanski 1999),(Hanski and Ovaskainen 2000)). Hanski and co-workers developed several of such metrics for patch-matrix representations of the landscape. In ConScape these different metrics are computed for continuous grid-based landscape representations. In the following we show the computation of the functionality of a pixel based: (1) on the RSP expected cost between source and target pixels and on the summation over sources or targets, (2) on eigenanalysis instead of summation, (3) on the survival probability instead of the RSP expected cost, (4) on the least-cost distance instead of the RSP expected cost. This last version corresponds to the popular ‘probability of connectivity’ ((Saura and Pascual-Hortal 2007))."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#functionality-rsp-expected-cost-with-summation",
    "href": "notebooks/nbk_functionality_variants.html#functionality-rsp-expected-cost-with-summation",
    "title": "Functional habitat",
    "section": "Functionality: RSP expected cost with summation",
    "text": "Functionality: RSP expected cost with summation\nBefore demonstrating the convenience function ConScape has to computate the amount of connected habitat, we will demonstrate explicitly the main building blocks going into this computation.\nFirst, we need extract the vectors with the qualities \\(s\\) of the pixels as source \\(s\\) and target \\(t\\):\n\ntargetidx, targetnodes = ConScape._targetidx_and_nodes(h.g)\nqˢ = [h.g.source_qualities[i] for i in h.g.id_to_grid_coordinate_list]\nqᵗ = [h.g.target_qualities[i] for i in targetidx];\n\nThen, we compute the proximity matrix between \\(s\\) and \\(t\\) using the RSP expected cost:\n\nK = map(t -> iszero(t) ? t : exp(-t/2000), ConScape.expected_cost(h));\n\nSee Notebook ecological distance for a discussion of the proximity computation.\nFrom the these quality vectors \\(q^s\\) and \\(q^t\\), and the proximity matrix \\(\\mathbf{K}\\) we compute the ‘landscape matrix’ \\(\\mathbf{M}\\):\n\nM = qˢ .* K .* qᵗ';\n\nThe landscape matrix \\(\\mathbf{M}\\) can be summarized either through summation or Eigenanalysis, both can be used to quantify the functionality of a pixel as a source or as a target. The next section demonstrates Eigenanalysis, we first look at summation to summarize \\(\\mathbf{M}\\). By summing over all rows, we get how well suitable target habitat is connected to suitable sources:\n\nfuncᵗ = vec(sum(M, dims=1)); #sum over rows\nConScape.plot_values(g, funcᵗ, title=\"Functional habitat\", color=cgrad(:viridis))\n\n\n\n\nFigure 1: Habitat functionality of each pixel as a target (i.e. in receiving suitable habitat from sources).\n\n\n\n\nSimilarly, by summing over all columns, we quantify how well suitable source habitat is connected to suitable target habitat:\n\nfuncˢ = vec(sum(M, dims=2)); #sum over columns\nConScape.plot_values(g, funcˢ, title=\"Functional habitat\", color=cgrad(:viridis))\n\n\n\n\nHabitat functionality of each pixel as a source (i.e. in contributing suitable habitat to targets).\n\n\n\n\nWe could then multiply the functionality of a pixel as a source and as a target to identify pixels that are simultaneously functional as source and target.\n\nfunc_tot = funcˢ .* funcᵗ;\n\nNote that this last computation is only possible, if func\\(^s\\) and func\\(^t\\) are of the same length. In other words, the the target qualities cannot be represented as a sparse matrix (see Van Moorter et al. 2022 and Notebook performance for more details).\nConScape’s convenience function focuses on the ‘source functionality’ to allow for the usage of the sparse matrix representation of target qualities, which allows the computation of these metrics on even larger landscapes (see Notebook performance for explanation):\n\nfunc = ConScape.connected_habitat(h, connectivity_function=\n    ConScape.expected_cost, distance_transformation=x -> exp(-x/2000));\nConScape.heatmap(func, yflip=true, color=cgrad(:viridis), title=\"Functional habitat\")\n\n\n\n\nHabitat functionality of each pixel as a target using ConScape’s convenience function.\n\n\n\n\nis identical to the one in Fig. Figure 1."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#functionality-rsp-expected-cost-with-eigenanalysis",
    "href": "notebooks/nbk_functionality_variants.html#functionality-rsp-expected-cost-with-eigenanalysis",
    "title": "Functional habitat",
    "section": "Functionality: RSP expected cost with eigenanalysis",
    "text": "Functionality: RSP expected cost with eigenanalysis\nIn addition to summarizing the landscape matrix \\(\\mathbf{M}\\) through summation, we can also use Eigenanalysis:\n\nvˡ, λ, vʳ= ConScape.eigmax(h, connectivity_function=\n    ConScape.expected_cost, distance_transformation=x -> exp(-x/2000))\n\nvʳ = real.(vʳ)\nvˡ = real.(vˡ);\n\nWhere \\(\\lambda\\) corresponds to the ‘metapopulation capacity’ in metapopulation ecology ((Hanski and Ovaskainen 2000)):\n\nλ\n\n354.16197335389097\n\n\nThe interpretation of this value outside the context of metapopulation theory still needs to be addressed in future research.\nThe right Eigenvector corresponds to the reproductive value, which is analogous to the functionality as a source:\n\nConScape.plot_values(g, vʳ, title=\"Reproductive value\", color=cgrad(:viridis))\n\n\n\n\nHabitat functionality based on eigenanalysis of each pixel as a target (i.e. the reproductive value).\n\n\n\n\nNote that the landscape matrix \\(\\mathbf{M}^{st}\\) is transposed compared to (e.g. (Ovaskainen and Hanski 2003)) and therefore the right and left Eigenvectors switched interpretation.\nThe left Eigenvector then corresponds to the stable distribution, which is somewhat analogous to the functionality as a target:\n\nConScape.plot_values(g, vˡ, title=\"Stable distribution\", color=cgrad(:viridis))\n\n\n\n\nHabitat functionality based on eigenanalysis of each pixel as a source (i.e. the stable distribution).\n\n\n\n\nJust as (Ovaskainen 2003) we can multiply the left and right Eigenvectors:\n\neigenvec = vˡ .* vʳ;\n\nAn important note, Eigenanalysis requires the landscape matrix \\(\\mathbf{M}^{st}\\) to be square, hence the sparse matrix representation of the target qualities is not possible (see main text and Notebook performance for more details). Hence, we cannot rely on the ‘landmark’ approach to reduce the computational demands, which currently limits this type of eigenanalysis to relatively coarse landscape representations."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#functionality-survival-probability-with-summation",
    "href": "notebooks/nbk_functionality_variants.html#functionality-survival-probability-with-summation",
    "title": "Functional habitat",
    "section": "Functionality: survival probability with summation",
    "text": "Functionality: survival probability with summation\nSee also Notebook ecological distance for more details on the different distance and proximity metrics that can be used. We now demonstrate the use of the survival probability as an alternative metric to compute the amount of suitable target habitat that is functionally connected to a suitable source pixel:\n\nfunc_surv = ConScape.connected_habitat(h,\n        connectivity_function=ConScape.survival_probability);\nConScape.heatmap(func_surv, yflip=true, title=\"Habitat functionality\", color=cgrad(:viridis))\n\n\n\n\nHabitat functionality based on survival probability.\n\n\n\n\nSee Notebook dispersal mortality for more details on the use of mortality data as the basis for survival connectivity."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#functionality-least-cost-distance-with-summation",
    "href": "notebooks/nbk_functionality_variants.html#functionality-least-cost-distance-with-summation",
    "title": "Functional habitat",
    "section": "Functionality: least-cost distance with summation",
    "text": "Functionality: least-cost distance with summation\nOur final demonstration to quantify the amount of connected habitat is related to the ‘probability of connectivity’ (Saura and Pascual-Hortal 2007) and the ‘cost-benefit analysis’ ((Drielsma, Ferrier, and Manion 2007),(Drielsma, Manion, and Ferrier 2007)). These approaches both are built from the least-cost distance between source and target pixels. Although the RSP expected cost in theory includes the least-cost distance for \\(\\theta \\rightarrow \\infty\\), it is not an efficient algorithm to use for least-cost based distances. We therefore implemented convenience functions to use Julia’s implementation of the Dijkstra algorithm to compute the least-cost distance:\n\nfunc_lc = ConScape.connected_habitat(g, connectivity_function=\n    ConScape.least_cost_distance, distance_transformation=x -> exp(-x/40));\n\nThe ‘connectivity of a landscape’ from ((Drielsma, Manion, and Ferrier 2007)) is then the sum of all elements in the landscape matrix \\(\\mathbf{M}^{st}\\):\n\nCL=sum(filter(x -> !isnan(x), func_lc))\n\n518459.3477832595\n\n\nAnd the ‘probability of connectivity’ further divides this ‘connectivity of the landscape’ by the squared area of the landscape ((Saura and Pascual-Hortal 2007)):\n\nPC=CL/sum(map(x -> isnan(x) ? 0 : 1, func_lc))^2\n\n0.01814760383958709\n\n\nIn addition, as above we can compute the source and target functionalities using the least-cost distance by respectively summing over all columns or all rows of the landscape matrix \\(\\mathbf{M}^{st}\\), this corresponds to the colonization potential in (Drielsma, Ferrier, and Manion 2007):\n\nConScape.heatmap(func_lc, yflip=true, title=\"Colonization potential\", color=cgrad(:viridis))\n\n\n\n\nHabitat functionality based on the least-cost distance, which corresponds to the ‘colonization potential’ in (Drielsma, Ferrier, and Manion 2007)."
  },
  {
    "objectID": "notebooks/nbk_functionality_variants.html#summary",
    "href": "notebooks/nbk_functionality_variants.html#summary",
    "title": "Functional habitat",
    "section": "Summary",
    "text": "Summary\nConScape allows for several different ‘habitat functionality’ metrics by combining different distance or proximity metrics to quantify the connectivity between sources and targets with different ways of summarizing across sources and/or targets. Theoretically, the RSP expected cost is a generalized version of the least-cost distance (i.e. RSP expected cost equals the least-cost distance for \\(\\theta \\rightarrow \\infty\\)), although numerical issues with the current algorithms prevent the usage of the RSP expected cost to replace the least-cost distance in actual applications. In addition to the RSP expected cost (and least-cost distance), ConScape also offers the survival probability to quantify the connectivity between source and target pixels. Two summary statistics have been proposed to quantify habitat functionality: summation and eigenanalysis. Summation was first proposed in (Hanski 1999) with the ‘neighborhood habitat area index’, whereas (Hanski and Ovaskainen 2000) proposed eigenanalysis to quantify the ‘metapopulation capacity’ for metapopulation persistence. Both of these approaches have been implemented in ConScape, however, the computational requirements for eigenanalysis may prevent this approach on large landscapes."
  },
  {
    "objectID": "notebooks/nbk_getting_started.html",
    "href": "notebooks/nbk_getting_started.html",
    "title": "Getting started",
    "section": "",
    "text": "Here you will learn\n\n\n\nThe basics of ConScape: importing data, running basic analyses, and exporting resulting maps.\nThis tutorial is very similar to the notebook in Appendix A from van Moorter et al. (2022). For a broad overview of the ConScape library, please refer to van Moorter et al. (2022).\nIn this first notebook we demonstrate the basic workflow as presented in van Moorter et al. (2022) to compute the amount of connected habitat and the movement flow in four steps:"
  },
  {
    "objectID": "notebooks/nbk_getting_started.html#install-conscape",
    "href": "notebooks/nbk_getting_started.html#install-conscape",
    "title": "Getting started",
    "section": "Install ConScape",
    "text": "Install ConScape\nIn the first time we use ConsCape, we need to install the library. This step can be ignored in the afterwards, unless the user wants to reinstall or update the ConScape library to a new version.\nWithin the Julia environment, installing ConScape is as simple as:\n\n# load Pkg library\nusing Pkg\n# install ConScape\nPkg.add(\"ConScape\")"
  },
  {
    "objectID": "notebooks/nbk_getting_started.html#load-libraries",
    "href": "notebooks/nbk_getting_started.html#load-libraries",
    "title": "Getting started",
    "section": "Load libraries",
    "text": "Load libraries\nWe continue, and usually would start, by loading the required libraries.\n\n# load libraries\nusing Pkg\nusing ConScape\nusing Plots\n\nThis step is similar to using the library() function in R or the import command in Python.\nWhen setting up the environment, it is also useful to setup the path to the folders where the input data are located and where we want to write the results of our analysis. Here we set the datadir data folder to the folder where the internal ConScape example datasets are saved, after the library is installed.\n\n# path to files\n# Pkg.activate(joinpath(ENV[\"HOMEPATH\"], \".julia\", \"packages\", \"ConScape\", \"spkWs\", \"data\"))\n\n# set folders\ndatadir = joinpath(ENV[\"HOMEPATH\"], \".julia\", \"packages\", \"ConScape\", \"spkWs\", \"data\")\noutdir = joinpath(ENV[\"TMP\"], \"figures\")\n# created the output folder, if it does not exist\nif !isdir(outdir)\n    mkdir(outdir)\nend"
  },
  {
    "objectID": "notebooks/nbk_getting_started.html#import-data",
    "href": "notebooks/nbk_getting_started.html#import-data",
    "title": "Getting started",
    "section": "Import data",
    "text": "Import data\nWe start by importing and checking the input data to be used in ConScape. The first ConScape function is a helper to read maps in ASCII format, the function readasc():\n\n# read habitat quality raster\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \"hab_qual_1000.asc\"))\n# read movemement probability raster\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \"mov_prob_1000.asc\"))\n\n([NaN NaN … NaN NaN; NaN NaN … NaN NaN; … ; NaN NaN … NaN NaN; NaN NaN … NaN NaN], Dict{Any, Any}(\"cellsize\" => 1000.0, \"nrows\" => 87, \"nodata_value\" => -9999, \"ncols\" => 117, \"xllcorner\" => 110650.0, \"yllcorner\" => 6.89575e6))\n\n\nThe function reads the map as a matrix and the meta data from the ASCII grid as a dictionary. ConScape natively reads ASC files, however, Julia allows easy reading of maps in other file formats through other libraries.\nThe meta data contain information about the maps: cell size/resolution, number of rows and columns, xy-coordinates of the lower left corner, and no data value:\n\nkeys(meta_p)\n\nKeySet for a Dict{Any, Any} with 6 entries. Keys:\n  \"cellsize\"\n  \"nrows\"\n  \"nodata_value\"\n  \"ncols\"\n  \"xllcorner\"\n  \"yllcorner\"\n\n\nThese meta data can be used to verify that the maps are representing the same geographic domain (i.e. cell size/resolution, number of rows and columns, xy-coordinates of the lower left corner):\n\ncollect(values(meta_p))[1:end .!= 3]\ncollect(values(meta_p))[1:end .!= 3] == collect(values(meta_q))[1:end .!= 3]\n\ntrue\n\n\nFinally, it is important to ensure that the cells with values match, we conduct the following check and remove non-matching cells:\n\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= NaN\nhab_qual[non_matches] .= NaN;\n\n\n\n\n\n\n\nWarning\n\n\n\nIt is important that all cells or pixels that can be reached in the network (i.e. those with values for the permeability maps) also have matching habitat quality. Otherwise, the ‘NaN’ values may propagate in computations further down. This code ensures this match."
  },
  {
    "objectID": "notebooks/nbk_getting_started.html#create-a-grid-object",
    "href": "notebooks/nbk_getting_started.html#create-a-grid-object",
    "title": "Getting started",
    "section": "Create a Grid object",
    "text": "Create a Grid object\nDefine a ConScape Grid:\n\nadjacency_matrix = ConScape.graph_matrix_from_raster(mov_prob)\ng = ConScape.Grid(size(mov_prob)..., \n                    affinities = adjacency_matrix,\n                    source_qualities = hab_qual,\n                    target_qualities = ConScape.sparse(hab_qual),\n                    costs = ConScape.mapnz(x -> -log(x), adjacency_matrix))\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n\nConScape.Grid of size 87x117Affinities\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\nSource qualities\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\nTarget qualities\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\nA ConScape Grid describes a graph from a grid of adjacent cells or pixels. It requires four main inputs: the quality of each pixel both as a source and as a target, the affinity between i and j (i.e. probabilities of moving between adjacent pixels i and j), and the cost of moving between between i and j. However, these four inputs can be reduced, for instance, by considering the quality of a pixel identical as a source and target, or by defining the cost as a function of the affinities (e.g. a logarithmic relationship). For our illustration, we introduced those two simplifications and only provided two independent data: the quality of a pixel (identical as source and as target) and the likelihood of moving between adjacent pixels. The likelihood of moving between adjacent pixels i and j was derived from a ‘permeability map’, which describes the permeability of a pixel i (and is similar to the conductivity in circuit theory). The function graph matrix from raster computes the values for an i − j pair from the map either by the average permeability of i and j (AverageWeight) or by the permeability of the target pixel j (TargetWeight; the default); the neighbors of a pixel can be defined either as rook (N4) or as queen (N8; the default).\nFrom the Grid, we can plot the qualities of the pixels:\n\nConScape.heatmap(g.source_qualities, yflip = true, \n                    title = \"Map of habitat uality\", \n                    color = cgrad([:white, :green]))\n# savefig(\"figure_grid_outdeg.png\")\n\n\n\n\nAnd the permeability:\n\nConScape.plot_outdegrees(g, title = \"Map of permeability to movement\", color = cgrad(:acton))\n\n\n\n\nThe information on affinity, cost and quality is stored in the Grid struct as matrices. This is a ‘dense’ matrix (all elements are explicitly stored) in the case of the source qualities:\n\ntypeof(g.source_qualities)\n\nMatrix{Float64} (alias for Array{Float64, 2})\n\n\nBut, a sparse matrix (only the non-zero elements are explicitly stored) for the affinities:\n\ntypeof(g.affinities)\n\nSparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\ncosts:\n\ntypeof(g.costmatrix)\n\nSparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nand target qualities:\n\ntypeof(g.target_qualities)\n\nSparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nNote the target qualities can be provided either as a sparse (as demonstrated), but also as a dense matrix. This sparse matrix representation forms the basis for the landmark implementation to improve computational performance, as demonstrated in Notebook.\nThe size of the landscape is given by:\n\n(g.nrows, g.ncols, g.nrows*g.ncols)\n\n(87, 117, 10179)"
  },
  {
    "objectID": "notebooks/nbk_getting_started.html#summary",
    "href": "notebooks/nbk_getting_started.html#summary",
    "title": "Getting started",
    "section": "Summary",
    "text": "Summary\nWe showed a basic workflow to demonstrate the main functionalities in the ConScape library. Step 1 is data import and the representation of the landscape as a Grid with connections between adjacent pixels i and j. Step 2 is the computation of the fundamental matrix in the GridRSP for the RSP distribution over all paths between all source \\(s\\) and target \\(t\\) pixels given the randomness of these paths (\\(\\theta\\) parameter). In steps 3 and 4 the main outputs are computed from the : the amount of connected habitat to each pixel and the movement flow through each pixel.\nThe following notebooks go into some more details of the different components of this basic workflow: Notebook~\\(\\ref{nbk:landmarks}\\) expands on improving computational performance by using a landmark approach, Notebook~\\(\\ref{nbk:distance}\\) discusses in more depth different distance metrics and their transformation to proximities, Notebook~\\(\\ref{nbk:cost}\\) illustrates the use of independent likelihood and cost of movement with mortality risks, and Notebook~\\(\\ref{nbk:functionality}\\) shows the different ways the amount of connected habitat to a pixel can be quantified using ."
  },
  {
    "objectID": "notebooks/nbk_iterative_method.html",
    "href": "notebooks/nbk_iterative_method.html",
    "title": "Numerical issues",
    "section": "",
    "text": "Here you will learn about\n\n\n\nNumerical issues that may arise with large values of \\(\\theta\\) (i.e. towards the optimum end of the continuum), and a partial solution to it."
  },
  {
    "objectID": "notebooks/nbk_iterative_method.html#summary",
    "href": "notebooks/nbk_iterative_method.html#summary",
    "title": "Numerical issues",
    "section": "Summary",
    "text": "Summary\nWe discussed numerical issues that may arise with large values of \\(\\theta\\), which prevent convergence of the RSP expected cost to the least-cost distance, together with possible solutions depending on the goal of the study."
  },
  {
    "objectID": "notebooks/nbk_landmarks.html",
    "href": "notebooks/nbk_landmarks.html",
    "title": "Performance",
    "section": "",
    "text": "Here you will learn\n\n\n\nHow to use a subsample of target pixels or landmarks to increase computational performance with minimal loss in accuracy.\nIn this notebook we demonstrate the use of landmarks with the coarse_graining function to reduce the computational demands in ConScape, see main text of details and discussion."
  },
  {
    "objectID": "notebooks/nbk_landmarks.html#amount-of-connected-habitat",
    "href": "notebooks/nbk_landmarks.html#amount-of-connected-habitat",
    "title": "Performance",
    "section": "Amount of connected habitat",
    "text": "Amount of connected habitat\nWe compute the amount of connected habitat or functionality for each pixel using the expected cost distance and an exponential decay for both the high-resolution and low-resolution target qualities:\n\nfunc = ConScape.connected_habitat(h, \n        distance_transformation=x -> exp(-x/75));\nfunc_coarse = ConScape.connected_habitat(h_coarse, \n        distance_transformation=x -> exp(-x/75));\n\n\ndisplay(ConScape.heatmap(func, yflip=true, title=\"Complete\", color=cgrad(:viridis)))\ndisplay(ConScape.heatmap(func_coarse, yflip=true, title=\"Landmark-based\", color=cgrad(:viridis)))\n\n\n\n\n\n\na\n\n\n\n\n\n\n\nb\n\n\n\n\n\n\nComparison of functional habitat without and with landmarks.\n\n\n\n\nCompare the computation based on all pixels versus the one based on landmarks and we see they are highly similar.\nHence, the correlation between these values is:\n\ncor(filter(x -> !isnan(x), func), filter(x -> !isnan(x), func_coarse))\n\n0.9995672056717685\n\n\nClearly, the estimation of the ranking of source pixels based upon their functional connectivity to target pixels is relatively little affected by the aggregation of these target pixels.\nWhen we look at the change in the amount of connected habitat in the landscape:\n\nsqrt(sum(filter(x -> !isnan(x), func_coarse)))/\n    sqrt(sum(filter(x -> !isnan(x), func)))\n\n0.9318905358312394\n\n\nThere is some under-estimation, however, note that we used a substantial level of coarse graining (i.e. \\(20 \\times 20\\)). We now investigate how the accuracy changes for different levels of coarse graining.\nWe compute both the correlation between pixel-level and landscape-level amount of connnected habitat over a range of aggregation levels (from 1, no aggregation, to 50):\n\ncoarseness = [1, 2, 3, 5, 7, 10, 15, 20, 50]\nest_func = zeros(length(coarseness))\ncor_func = zeros(length(coarseness))\n\nfor i in 1:length(coarseness)\n    g_tmp = ConScape.Grid(size(mov_prob)...,\n        affinities=adjacency_matrix,\n        source_qualities=hab_qual,\n        target_qualities=ConScape.coarse_graining(g, coarseness[i]),\n        costs=ConScape.mapnz(x -> -log(x), adjacency_matrix))\n    @time h_tmp = ConScape.GridRSP(g_tmp, θ=θ);\n    func_coarse = ConScape.connected_habitat(h_tmp, distance_transformation=x -> exp(-x/75));\n    \n    est_func[i] = sum(filter(x -> !isnan(x), func_coarse))\n    cor_func[i] = cor(filter(x -> !isnan(x), func), filter(x -> !isnan(x), func_coarse))\nend\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n  6.300860 seconds (10.74 k allocations: 1.865 GiB, 3.46% gc time, 0.05% compilation time)\n\n\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n  1.575205 seconds (2.83 k allocations: 489.299 MiB, 3.27% gc time)\n\n\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n  0.690620 seconds (1.37 k allocations: 225.532 MiB)\n\n\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n  0.264900 seconds (604 allocations: 89.050 MiB)\n\n\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n  0.168667 seconds (409 allocations: 52.960 MiB, 10.36% gc time)\n\n\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n\n\n  0.082171 seconds (286 allocations: 32.027 MiB)\n\n\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n  0.050841 seconds (229 allocations: 21.921 MiB)\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n  0.039497 seconds (208 allocations: 18.312 MiB)\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n\n  0.047757 seconds (199 allocations: 14.704 MiB, 34.40% gc time)\n\n\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n\n\n\n\n\n\nplot(coarseness, cor_func, ylims=(0.0, 1.0), label=nothing)\n\n\n\n\nThe correlation between the full and landmark-based habitat functionality in function of the level of ‘coarse graining’.\n\n\n\n\nThe ranking of source pixels based on their functional connectivity to high-quality target pixels, is hardly affected by aggregation. Aggregating less than \\(10 \\times 10\\) pixels results in a virtual identical ranking, whereas even sever levels of aggregation (\\(50 \\times 50\\)) still result in a correlation above \\(0.98\\).\nHowever, as we saw above, the loss in accuracy is a bit more pronounced for the amount of connnected habitat:\n\nplot(coarseness, sqrt.(est_func)/\n            sqrt.(sum(sum(filter(x -> !isnan(x), func)))), \n        ylims=(0.0, 1.0), label=nothing)\n\n\n\n\nThe estimated landscape functionnality based on landmarks as a proportion of the full computation against the level of ‘coarse graining’.\n\n\n\n\nWe can see in our example that aggregating less than 10 pixels will result in less than 1% drop in estimated amount of connected habitat, but increasing the level of aggregation will result in an accelerating underestimation of the actual amount of connected habitat."
  },
  {
    "objectID": "notebooks/nbk_landmarks.html#summary",
    "href": "notebooks/nbk_landmarks.html#summary",
    "title": "Performance",
    "section": "Summary",
    "text": "Summary\nThe function coarse_graining in the ConScape library is a useful tool to reduce the computational demands of dealing with high-resolution landscapes by connecting a high-resolution map of source pixels to a lower resolution map of target pixels. Unfortunately, the computational benefits come at the cost of a loss in accuracy. We found for our example that aggregation levels below 10 led to a substantial benefit in terms of computation with minimal loss in accuracy. It is however beyond the scope of this study to investigate in detail the shape of this trade-off for a large range of landscapes. We suggest that researchers explore how the accuracy changes in their landscape with changing levels of aggregation."
  },
  {
    "objectID": "notebooks/nbk_other_raster_formats.html",
    "href": "notebooks/nbk_other_raster_formats.html",
    "title": "Other raster formats",
    "section": "",
    "text": "Here you will learn\n\n\n\nHow to use other raster file formats in ConScape.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis notebook assumes familiarity with the basics as covered in the notebook Getting Started\n\n\n\n\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n\n\n\n# load Rasters library\nusing Rasters\n# read habitat quality using Rasters()\nhab_qual = Raster(joinpath(datadir, \"hab_qual_1000_tif.tif\"))\n\nSuch a raster can easily be converted to a matrix for use in ConScape:\n\n# Replace missing values by NaN and transform into a matrix\nhab_qual = replace_missing(hab_qual, NaN)\nhab_qual = Matrix(transpose(Array(hab_qual)[:,:,1]))"
  },
  {
    "objectID": "notebooks/nbk_test.html",
    "href": "notebooks/nbk_test.html",
    "title": "Test",
    "section": "",
    "text": "Getting Started dispersal mortality ecological distance performance Functional habitat numerical issues\n\n#display(\n\n\nFigure 1: Comparison of functional habitat with and without landmarks.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.\n\n\n\n\n\n\n\n\nTip With Caption\n\n\n\nThis is an example of a callout with a caption.\n\n\n\n\n\n\n\n\nExpand To Learn About Collapse\n\n\n\n\n\nThis is an example of a ‘folded’ caution callout that can be expanded by the user. You can use collapse=\"true\" to collapse it by default or collapse=\"false\" to make a collapsible callout that is expanded by default."
  },
  {
    "objectID": "posts/ConScape_goes-live/index.html",
    "href": "posts/ConScape_goes-live/index.html",
    "title": "ConScape goes live",
    "section": "",
    "text": "After several years of hard work, in April 22, 2022, we published the ConScape library in Methods in Ecology and Evolution here. We are now developing a website to serve users with updates and supplementary information based on feedback we are receiving. So, please, get in touch for questions, issue, etc."
  },
  {
    "objectID": "quick_start.html",
    "href": "quick_start.html",
    "title": "Quick start",
    "section": "",
    "text": "ConScape is a library for the Julia programming language (Why Julia?).\n\n\nJulia can be downloaded here\n\n\n\n\n\n\nWarning\n\n\n\nConScape requires a julia version ≥ 1.6\n\n\nA nice youtube tutorial on the installation of Julia and the integrated development environment VS Code:\n\n\n\nYT thumbnail\n\n\n\n\n\nThere are several integrated development environments for Julia, we use VS Code ourselves (which is easy to set up and use as shown here).\nFor R users, it seems that the Rstudio team is working on a multi language environment that also would support Julia. We will follow this with great interest.\n\n\n\n\nTo install ConScape from Julia’s package manager:\n(v1.6) pkg> add ConScape\nor easier, directly from Julia:\njulia> using Pkg\njulia> Add.pkg(\"ConScape\")\njulia> using ConScape\n\n\n\nNow you are ready to start with the first notebook presenting a basic workflow for connectivity analysis using ConScape."
  },
  {
    "objectID": "team.html",
    "href": "team.html",
    "title": "The team and contact",
    "section": "",
    "text": "Contact\nYou can contact the corresponding author here\n\n\nThe team"
  }
]