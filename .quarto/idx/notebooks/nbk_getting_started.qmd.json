{"title":"Getting started","markdown":{"yaml":{"title":"Getting started"},"headingText":"Here you will learn","containsRefs":false,"markdown":"\n\n::: {.callout-tip}\n\nThe basics of ConScape: importing data, running basic analyses, and exporting resulting maps.\n:::\n\nThis tutorial is very similar to the notebook in Appendix A from van Moorter et al. (2022). For a broad overview of the ConScape library, please refer to van Moorter et al. (2022). \n\nIn this first notebook we demonstrate the basic workflow as presented in van Moorter et al. (2022) \nto compute the amount of connected habitat and the movement flow in four steps:\n1. data import and Grid creation;\n2. computation of the GridRSP;\n3. computation of the amount of connected habitat;\n4. movement flow in two variants (weighted by quality or by proximity).\n\n\n# Setup the environment\n\n::: {.callout-warning}\nThis notebook assumes a running installation of Julia. If you didn't already install Julia go [here](/quick_start.qmd).\n:::\n\n## Install ConScape\n\nIn the first time we use ConsCape, we need to install the library. This step can be ignored in the afterwards,\nunless the user wants to reinstall or update the ConScape library to a new version.\n\nWithin the Julia environment, installing ConScape is as simple as:\n\n```{julia}\n#| eval: false\n\n# load Pkg library\nusing Pkg\n# install ConScape\nPkg.add(\"ConScape\")\n```\n\nWe will also install other libraries that will be used in this notebook, but they are not\nnecessary to run ConScape.\n\n```{julia}\n#| eval: false\n\n# complementary libraries, to be used in this notebook\nPkg.add(\"Rasters\")\n```\n\n## Load libraries\n\nWe continue, and usually would start, by loading the required libraries.\n\n```{julia}\n# load libraries\nusing Pkg\nusing ConScape\nusing Plots\n```\n\nThis step is similar to using the `library()` function in R or the `import` command in Python.\n\nWhen setting up the environment, it is also useful to setup the path to the folders where the input data are located\nand where we want to write the results of our analysis. Here we set the `datadir` data folder to the folder where\nthe internal ConScape example datasets are saved, after the library is installed.\n\n```{julia}\n#| eval: false\n\n# path to files\n# Pkg.activate(joinpath(ENV[\"HOMEPATH\"], \".julia\", \"packages\", \"ConScape\", \"spkWs\", \"data\"))\n\n# set folders\ndatadir = joinpath(ENV[\"HOMEPATH\"], \".julia\", \"packages\", \"ConScape\", \"spkWs\", \"data\")\noutdir = joinpath(ENV[\"TMP\"], \"figures\")\n# created the output folder, if it does not exist\nif !isdir(outdir)\n    mkdir(outdir)\nend\n```\n\n# Step 1: Data import and grid creation\n\n## Import data\n\nWe start by importing and checking the input data to be used in ConScape.\nThe first ConScape function is a helper to read maps in ASCII format, the function `readasc()`:\n\n```{julia}\ndatadir = \"P:/12084000_egenutvikling_bram_van_moorter/Conscape_development/test/data/\"\n# read habitat quality raster\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \"hab_qual_1000.asc\"))\n# read movemement probability raster\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \"mov_prob_1000.asc\"))\n```\n\nThe function reads the map as a matrix and the meta data from the ASCII grid as a dictionary.\nConScape natively reads ASC files, however, Julia allows easy reading of maps in other file\nformats through other libraries, for instance:\n\n**This chunk below is not working!!! Missing file!!**\nWouldn't it be much easier to create a function readrast within ConScape?\nOr this would increase the dependencies (to Rasters), which is undesiderable?\n\n```{julia}\n#| eval: false\n# load Rasters library\nusing Rasters\n# read habitat quality using Rasters()\nhab_qual = Raster(joinpath(datadir, \"hab_qual_1000_tif.tif\"))\n```\n\nSuch a raster can easily be converted to a matrix for use in ConScape:\n\n```{julia}\n#| eval: false\n# Replace missing values by NaN and transform into a matrix\nhab_qual = replace_missing(hab_qual, NaN)\nhab_qual = Matrix(transpose(Array(hab_qual)[:,:,1]))\n```\n\nThe meta data can be used to verify that the maps are representing the same geographic domain\n(i.e. cell size/resolution, number of rows and columns, xy-coordinates of the lower left corner):\n\n**Which of the following options should we use? They were present in different versions of the notebook**\n\n```{julia}\nvalues(meta_p)\ncollect(values(meta_p))[1:end .!= 3]\ncollect(values(meta_p))[1:end .!= 3] == collect(values(meta_q))[1:end .!= 3]\n```\n\n```{julia}\n#| eval: false\ndelete!(meta_p, \"nodata_value\")\ndelete!(meta_q, \"nodata_value\")\nmeta_p == meta_q\n```\n\nTo ensure that the cells with values match, we conduct the following check and remove non-matching cells:\n\n**Check here**\n\n```{julia}\n#| eval: true\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= NaN\nhab_qual[non_matches] .= NaN;\n```\n\n## Create a `Grid` object\n\nDefine a `ConScape Grid`:\n\n```{julia}\nadjacency_matrix = ConScape.graph_matrix_from_raster(mov_prob)\ng = ConScape.Grid(size(mov_prob)..., \n                    affinities = adjacency_matrix,\n                    source_qualities = hab_qual,\n                    target_qualities = ConScape.sparse(hab_qual),\n                    costs = ConScape.mapnz(x -> -log(x), adjacency_matrix))\n```\n\nA `ConScape Grid` describes a graph from a grid of adjacent cells or pixels. It requires four\nmain inputs: the quality of each pixel both as a source and as a target, the affinity between `i` and\n`j` (i.e. probabilities of moving between adjacent pixels `i` and `j`), and the cost of moving between\nbetween `i` and `j`. However, these four inputs can be reduced, for instance, by considering the\nquality of a pixel identical as a source and target, or by defining the cost as a function of the\naffinities (e.g. a logarithmic relationship). For our illustration, we introduced those two simplifications and only provided two independent data: the quality of a pixel (identical as source\nand as target) and the likelihood of moving between adjacent pixels. The likelihood of moving between adjacent pixels `i` and `j` was derived from a ‘permeability map’, which describes\nthe permeability of a pixel `i` (and is similar to the conductivity in circuit theory). The function\ngraph matrix from raster computes the values for an `i` − `j` pair from the map either by\nthe average permeability of `i` and `j` (AverageWeight) or by the permeability of the target pixel\n`j` (TargetWeight; the default); the neighbors of a pixel can be defined either as rook (N4)\nor as queen (N8; the default).\n\nFrom the `Grid`, we can plot the qualities of the pixels:\n\n```{julia}\nConScape.heatmap(g.source_qualities, yflip = true, \n                    title = \"Map of habitat uality\", \n                    color = cgrad([:white, :green]))\n# savefig(\"figure_grid_outdeg.png\")\n```\n\nAnd the permeability:\n\n```{julia}\nConScape.plot_outdegrees(g, title = \"Map of permeability to movement\", color = cgrad(:acton))\n```\n\n\n```{julia}\ntypeof(g.source_qualities)\n```\n\n```{julia}\ntypeof(g.affinities)\ntypeof(g.costmatrix)\ntypeof(g.costmatrix)\n```\n\n```{julia}\n(g.nrows, g.ncols, g.nrows*g.ncols)\n```\n\n# Step 2: GridRSP creation\n\n```{julia}\n@time h = ConScape.GridRSP(g, θ = 1.0)\n```\n\nCompute derived metrics.\nDistance from all pixels to a given target pixel.\n\nPixel 4300 is our target:\n\n```{julia}\n#| eval: false\n\ntmp = zeros(10179)#5345) #g.nrows * g.ncols\ntmp[4300] = 1\nConScape.plot_values(g, tmp, title = \"One target pixel t\")\n```\n\nEcological distances from all s to t are:\n\n```{julia}\ndists = ConScape.expected_cost(h)\nConScape.plot_values(g, dists[:,4300], title = \"Ecological distances to target pixel t\")\n```\n\nProximity instead of distance\n\n```{julia}\nConScape.plot_values(g, map!(x -> exp(-x/75), dists[:,4300], dists[:,4300]), \n                        title = \"Proximity to target pixel t\")\n```\n\n# Computation of habitat functionality\n\nCompute\n\n```{julia}\nfunc = ConScape.connected_habitat(h, \n                    connectivity_function = ConScape.expected_cost,\n                    distance_transformation=x -> exp(-x/75));\n\n# func = ConScape.connected_habitat(h, distance_transformation=x -> exp(-x/75));\n\n```\n\nPlot\n\n```{julia}\nConScape.heatmap(Array(func), yflip = true, title = \"Map of habitat functionality\")\n```\n\n```{julia}\nsum(func)\nsum(filter(!isnan, func))\n```\n\n# Movement flow\n\n```{julia}\nConScape.heatmap(ConScape.betweenness_qweighted(h), yflip = true, title = \"g\")\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"nbk_getting_started.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","theme":{"light":"flatly","dark":"darkly"},"code-copy":true,"title":"Getting started"},"extensions":{"book":{"multiFile":true}}}}}