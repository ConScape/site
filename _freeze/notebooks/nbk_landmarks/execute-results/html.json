{
  "hash": "00f527b76c6a7ea6bec919ff997049e0",
  "result": {
    "markdown": "---\ntitle: \"Performance\"\nbibliography: biblio.bib\n---\n\n::: {.callout-tip}\n## Here you will learn\n\nHow to use a subsample of target pixels or landmarks to increase computational performance with minimal loss in accuracy.\n:::\n\nIn this notebook we demonstrate the use of landmarks with the `coarse_graining` function to reduce the computational demands in ConScape, see main text of details and discussion.\n\n# Data import and `Grid` creation\n\nSee notebook [getting started](/notebooks/nbk_getting_started.qmd) for a 'basic workflow' to learn about data import and the creation of a ConScape `Grid`:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing ConScape\nusing SparseArrays\nusing Statistics\nusing Plots\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ndatadir = joinpath(ENV[\"HOME\"], \"Downloads\", \"input_maps\")\noutdir = joinpath(ENV[\"TMPDIR\"], \"figures\")\nif !isdir(outdir)\n    mkdir(outdir)\nend\n```\n:::\n\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \"mov_prob_1000.asc\"))\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \"hab_qual_1000.asc\"));\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= NaN\nhab_qual[non_matches] .= NaN;\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nadjacency_matrix = ConScape.graph_matrix_from_raster(mov_prob)\ng = ConScape.Grid(size(mov_prob)...,\n    affinities=adjacency_matrix,\n    source_qualities=hab_qual,\n    target_qualities=ConScape.sparse(hab_qual),\n    costs=ConScape.mapnz(x -> -log(x), adjacency_matrix));\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n:::\n\n\n# Coarse graining\n\nWe remind the reader that the target qualities can be represented by a sparse matrix:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\ntypeof(g.target_qualities)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nSparseMatrixCSC{Float64, Int64}\n```\n:::\n:::\n\n\nThus, habitat of quality zero is not explicitly stored in the matrix, which reduces the memory footprint in case of matrices with many zeros.\nWe can now further increase the sparseness of this matrix to reduce the computational requirements in terms of processing time, but especially also in terms of memory requirements. ConScape currently has a function to facilitate this process, the function `coarse_graining` will merge a number of pixel (20 in our example) along both the x and y axis. It does so by summing the target qualities of all pixels and assigning this value to the center pixel, while setting all other cells to zero. The idea is thus to connect pixels from a higher resolution source map to a lower resolution target map. The benefit of this approach compared to, for instance, using lower resolution maps in general is that movement paths are still represented with a high resolution. The main assumption underlying the use of these low-resolution target qualities is that all high-resolution pixels within a coarse pixel are equally well connected to the source pixel as the high-resolution pixel at the center of the coarse pixel. This assumption will be more difficult to meet with increasing number of pixels aggregated and with increasing heterogeneity in the landscape.\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\ncoarse_target_qualities = ConScape.coarse_graining(g, 20)\ng_coarse = ConScape.Grid(size(mov_prob)...,\n    affinities=adjacency_matrix,\n    source_qualities=hab_qual,\n    target_qualities=coarse_target_qualities,\n    costs=ConScape.mapnz(x -> -log(x), adjacency_matrix));\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nθ = 1.0\n@time h = ConScape.GridRSP(g, θ=θ);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 11.453773 seconds (10.29 M allocations: 2.448 GiB, 4.15% gc time, 44.66% compilation time)\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n@time h_coarse = ConScape.GridRSP(g_coarse, θ=θ);\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.038946 seconds (198 allocations: 18.312 MiB)\n```\n:::\n:::\n\n\nThe reduction in computation is substantial. The processing time goes from 16 to 0.05 seconds and the memory requirements from 2.5 Gb to 18 Mb by aggregating $20 \\times 20$ pixels into a single pixel. Obviously, the reduction in computation will be less with lower numbers of pixels aggregated. However, even merging as few as 2 or 3 pixels will result in substantial reductions in computation (respectively 2.6 and 1.2 seconds of processing time, and 503 Mb and 232 Mb of memory). \n\nWe will now investigate how the estimation of the amount of connected habitat and the movement flow are affected by this coarse graining of the target pixels.\n\n## Amount of connected habitat\n\nWe compute the amount of connected habitat or functionality for each pixel using the expected cost distance and an exponential decay for both the high-resolution and low-resolution target qualities:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfunc = ConScape.connected_habitat(h, \n        distance_transformation=x -> exp(-x/75));\nfunc_coarse = ConScape.connected_habitat(h_coarse, \n        distance_transformation=x -> exp(-x/75));\n```\n:::\n\n\n::: {.cell layout-ncol='2' execution_count=12}\n``` {.julia .cell-code}\ndisplay(ConScape.heatmap(func, yflip=true, title=\"Complete\", color=cgrad(:viridis)))\ndisplay(ConScape.heatmap(func_coarse, yflip=true, title=\"Landmark-based\", color=cgrad(:viridis)))\n```\n\n::: {.cell-output .cell-output-display}\n![a](nbk_landmarks_files/figure-html/cell-13-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display}\n![b](nbk_landmarks_files/figure-html/cell-13-output-2.svg){}\n:::\n\nComparison of functional habitat without and with landmarks.\n:::\n\n\nCompare the computation based on all pixels versus the one based on landmarks and we see they are highly similar.\n\nHence, the correlation between these values is:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\ncor(filter(x -> !isnan(x), func), filter(x -> !isnan(x), func_coarse))\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n0.9995672056717685\n```\n:::\n:::\n\n\nClearly, the estimation of the ranking of source pixels based upon their functional connectivity to target pixels is relatively little affected by the aggregation of these target pixels. \n\nWhen we look at the change in the amount of connected habitat in the landscape:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nsqrt(sum(filter(x -> !isnan(x), func_coarse)))/\n    sqrt(sum(filter(x -> !isnan(x), func)))\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n0.9318905358312394\n```\n:::\n:::\n\n\nThere is some under-estimation, however, note that we used a substantial level of coarse graining (i.e. $20 \\times 20$). We now investigate how the accuracy changes for different levels of coarse graining.\n\nWe compute both the correlation between pixel-level and landscape-level amount of connnected habitat over a range of aggregation levels (from 1, no aggregation, to 50):\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\ncoarseness = [1, 2, 3, 5, 7, 10, 15, 20, 50]\nest_func = zeros(length(coarseness))\ncor_func = zeros(length(coarseness))\n\nfor i in 1:length(coarseness)\n    g_tmp = ConScape.Grid(size(mov_prob)...,\n        affinities=adjacency_matrix,\n        source_qualities=hab_qual,\n        target_qualities=ConScape.coarse_graining(g, coarseness[i]),\n        costs=ConScape.mapnz(x -> -log(x), adjacency_matrix))\n    @time h_tmp = ConScape.GridRSP(g_tmp, θ=θ);\n    func_coarse = ConScape.connected_habitat(h_tmp, distance_transformation=x -> exp(-x/75));\n    \n    est_func[i] = sum(filter(x -> !isnan(x), func_coarse))\n    cor_func[i] = cor(filter(x -> !isnan(x), func), filter(x -> !isnan(x), func_coarse))\nend\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  6.300860 seconds (10.74 k allocations: 1.865 GiB, 3.46% gc time, 0.05% compilation time)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.575205 seconds (2.83 k allocations: 489.299 MiB, 3.27% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.690620 seconds (1.37 k allocations: 225.532 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.264900 seconds (604 allocations: 89.050 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.168667 seconds (409 allocations: 52.960 MiB, 10.36% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.082171 seconds (286 allocations: 32.027 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.050841 seconds (229 allocations: 21.921 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.039497 seconds (208 allocations: 18.312 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  0.047757 seconds (199 allocations: 14.704 MiB, 34.40% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nplot(coarseness, cor_func, ylims=(0.0, 1.0), label=nothing)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![The correlation between the full and landmark-based habitat functionality in function of the level of 'coarse graining'.](nbk_landmarks_files/figure-html/cell-17-output-1.svg){}\n:::\n:::\n\n\nThe ranking of source pixels based on their functional connectivity to high-quality target pixels, is hardly affected by aggregation. Aggregating less than $10 \\times 10$ pixels results in a virtual identical ranking, whereas even sever levels of aggregation ($50 \\times 50$) still result in a correlation above $0.98$. \n\nHowever, as we saw above, the loss in accuracy is a bit more pronounced for the amount of connnected habitat:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nplot(coarseness, sqrt.(est_func)/\n            sqrt.(sum(sum(filter(x -> !isnan(x), func)))), \n        ylims=(0.0, 1.0), label=nothing)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![The estimated landscape functionnality based on landmarks as a proportion of the full computation against the level of 'coarse graining'.](nbk_landmarks_files/figure-html/cell-18-output-1.svg){}\n:::\n:::\n\n\nWe can see in our example that aggregating less than 10 pixels will result in less than 1% drop in estimated amount of connected habitat, but increasing the level of aggregation will result in an accelerating underestimation of the actual amount of connected habitat.\n\n# Movement flow\n\nWe compute the betweenness or movement flow for each pixel for both the high-resolution and low-resolution ($20 \\times 20$) target qualities, first for the quality weighted version:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nqbetw = ConScape.betweenness_qweighted(h);\nqbetw_coarse = ConScape.betweenness_qweighted(h_coarse);\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\ncor(filter(x -> !isnan(x), qbetw), filter(x -> !isnan(x), qbetw_coarse))\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n0.9310641946569057\n```\n:::\n:::\n\n\nAlthough, there is still a high correlation, this drop in accuracy is actually perceivable in the maps:\n\n::: {.cell layout-ncol='2' execution_count=20}\n``` {.julia .cell-code}\ndisplay(ConScape.heatmap(qbetw, yflip=true, title=\"Complete\"))\ndisplay(ConScape.heatmap(qbetw_coarse, yflip=true, title=\"Landmark-based\"))\n```\n\n::: {.cell-output .cell-output-display}\n![a](nbk_landmarks_files/figure-html/cell-21-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display}\n![b](nbk_landmarks_files/figure-html/cell-21-output-2.svg){}\n:::\n\nComparison of quality-weighted betweenness without and with landmarks.\n:::\n\n\nWe found similar results for the quality and proximity weighted version of the betweenness: \n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nkbetw = ConScape.betweenness_kweighted(h, \n        distance_transformation=x -> exp(-x/75));\nkbetw_coarse = ConScape.betweenness_kweighted(h_coarse, \n        distance_transformation=x -> exp(-x/75));\n```\n:::\n\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\ncor(filter(x -> !isnan(x), kbetw), filter(x -> !isnan(x), kbetw_coarse))\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0.9227035681051887\n```\n:::\n:::\n\n\n::: {.cell layout-ncol='2' execution_count=23}\n``` {.julia .cell-code}\ndisplay(ConScape.heatmap(kbetw, yflip=true, title=\"Complete\"))\ndisplay(ConScape.heatmap(kbetw_coarse, yflip=true, title=\"Landmark-based\"))\n```\n\n::: {.cell-output .cell-output-display}\n![a](nbk_landmarks_files/figure-html/cell-24-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display}\n![b](nbk_landmarks_files/figure-html/cell-24-output-2.svg){}\n:::\n\nComparison of proximity-weighted betweenness without and with landmarks.\n:::\n\n\nAs commented above, a $20 \\times 20$ aggregation of pixels is quite a high level of compression. Let's now see how the accuracy changes with changing levels of aggregation.\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\ncor_qbetw = zeros(length(coarseness))\ncor_kbetw = zeros(length(coarseness))\n\nfor i in 1:length(coarseness)\n    g_tmp = ConScape.Grid(size(mov_prob)...,\n        affinities=adjacency_matrix,\n        source_qualities=hab_qual,\n        target_qualities=ConScape.coarse_graining(g, coarseness[i]),\n        costs=ConScape.mapnz(x -> -log(x), adjacency_matrix));\n    @time h_tmp = ConScape.GridRSP(g_tmp, θ=θ);\n    qbetw_coarse = ConScape.betweenness_qweighted(h_tmp);\n    kbetw_coarse = ConScape.betweenness_kweighted(h_tmp, distance_transformation=x -> exp(-x/75));\n    \n    cor_qbetw[i] = cor(filter(x -> !isnan(x), qbetw), \n                        filter(x -> !isnan(x), qbetw_coarse));\n    cor_kbetw[i] = cor(filter(x -> !isnan(x), kbetw), \n                        filter(x -> !isnan(x), kbetw_coarse))\n\nend\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  6.324084 seconds (10.72 k allocations: 1.865 GiB, 3.75% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.629167 seconds (2.83 k allocations: 489.299 MiB, 4.61% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.706102 seconds (1.37 k allocations: 225.532 MiB, 3.52% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.332838 seconds (604 allocations: 89.050 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.166136 seconds (403 allocations: 52.959 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.108359 seconds (300 allocations: 32.028 MiB, 18.55% gc time)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  0.051413 seconds (229 allocations: 21.921 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  0.039615 seconds (208 allocations: 18.312 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  0.043662 seconds (183 allocations: 14.703 MiB)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4927 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 4926 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\n::: {.cell layout-ncol='2' execution_count=25}\n``` {.julia .cell-code}\ndisplay(plot(coarseness, cor_qbetw, ylims=(0.0, 1.0), label=\"Quality-weighted betweenness\"))\ndisplay(plot(coarseness, cor_kbetw, ylims=(0.0, 1.0), label=\"Proximity-weighted betweenness\"))\n```\n\n::: {.cell-output .cell-output-display}\n![a](nbk_landmarks_files/figure-html/cell-26-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display}\n![b](nbk_landmarks_files/figure-html/cell-26-output-2.svg){}\n:::\n\nThe correlation between the full and landmark-based betweenness in function of the level of 'coarse graining'.\n:::\n\n\nWe see that the level of accuracy is rather high for levels of aggregation below 10, but starts to drop off rather rapidly above this. \n\n## Summary\nThe function `coarse_graining` in the ConScape library is a useful tool to reduce the computational demands of dealing with high-resolution landscapes by connecting a high-resolution map of source pixels to a lower resolution map of target pixels. Unfortunately, the computational benefits come at the cost of a loss in accuracy. We found for our example that aggregation levels below 10 led to a substantial benefit in terms of computation with minimal loss in accuracy. It is however beyond the scope of this study to investigate in detail the shape of this trade-off for a large range of landscapes. We suggest that researchers explore how the accuracy changes in their landscape with changing levels of aggregation. \n\n",
    "supporting": [
      "nbk_landmarks_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}