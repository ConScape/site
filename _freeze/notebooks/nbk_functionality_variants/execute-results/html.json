{
  "hash": "56c8710861a76fd300bfa1e0c20fcf47",
  "result": {
    "markdown": "---\ntitle: \"Functional habitat\"\nbibliography: biblio.bib\n---\n\n::: {.callout-tip}\n## Here you will learn\n\nDifferent ways to compute the amount of connected habitat for a pixel/cell or functional habitat in ConScape.\n:::\n\n# Demonstration of functional habitat computation\n\nIn this notebook we demonstrate the different ways the amount of connected habitat or `habitat functionality' can be computed with ConScape.\n\n## Data import, `Grid` and `GridRSP` creation\n\nSee notebook [Getting Started](/notebooks/nbk_getting_started.qmd) for a 'basic workflow' to learn about the fundamentals on data import and the creation of a ConScape `Grid`:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n#using Pkg\n#Pkg.activate(joinpath(ENV[\"HOME\"], \".julia\", \"dev\", \"ConScape\"))\n\nusing ConScape\nusing SparseArrays\nusing Statistics\nusing Plots\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ndatadir = joinpath(ENV[\"HOME\"], \"Downloads\", \"input_maps\")\noutdir = joinpath(ENV[\"TMPDIR\"], \"figures\")\nif !isdir(outdir)\n    mkdir(outdir)\nend\n```\n:::\n\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \"mov_prob_1000.asc\"))\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \"hab_qual_1000.asc\"));\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nnon_matches = findall(xor.(isnan.(mov_prob), isnan.(hab_qual)))\nmov_prob[non_matches] .= 1e-20\nhab_qual[non_matches] .= 1e-20;\n```\n:::\n\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nθ = 1.0\nadjacency_matrix = ConScape.graph_matrix_from_raster(mov_prob)\ng = ConScape.Grid(size(mov_prob)...,\n    affinities=adjacency_matrix,\n    qualities=hab_qual,\n    costs=ConScape.mapnz(x -> -log(x), adjacency_matrix))\nh = ConScape.GridRSP(g, θ = θ);\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 4835 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: removing 4834 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n:::\n\n\n## Habitat functionality: introduction\n\nWe have defined the functionality of habitat as its suitability and its functional connectivity to suitable habitat, which has its background in metapopulation theory ([@hanski1999metapopulation],[@hanski2000metapopulation]). Hanski and co-workers developed several of such metrics for patch-matrix representations of the landscape. In ConScape these different metrics are computed for continuous grid-based landscape representations. In the following we show the computation of the functionality of a pixel based: (1) on the RSP expected cost between source and target pixels and on the summation over sources or targets, (2) on eigenanalysis instead of summation, (3) on the survival probability instead of the RSP expected cost, (4) on the least-cost distance instead of the RSP expected cost. This last version corresponds to the popular 'probability of connectivity' ([@saura2007new]).  \n\n## Functionality: RSP expected cost with summation\n\nBefore demonstrating the convenience function ConScape has to computate the amount of connected habitat, we will demonstrate explicitly the main building blocks going into this computation.\n\nFirst, we need extract the vectors with the qualities $s$ of the pixels as source $s$ and target $t$:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\ntargetidx, targetnodes = ConScape._targetidx_and_nodes(h.g)\nqˢ = [h.g.source_qualities[i] for i in h.g.id_to_grid_coordinate_list]\nqᵗ = [h.g.target_qualities[i] for i in targetidx];\n```\n:::\n\n\nThen, we compute the proximity matrix between $s$ and $t$ using the RSP expected cost:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nK = map(t -> iszero(t) ? t : exp(-t/2000), ConScape.expected_cost(h));\n```\n:::\n\n\nSee Notebook [ecological distance](/notebooks/nbk_distance_metrics.qmd) for a discussion of the proximity computation.\n\n\nFrom the these quality vectors $q^s$ and $q^t$, and the proximity matrix $\\mathbf{K}$ we compute the 'landscape matrix' $\\mathbf{M}$:  \n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nM = qˢ .* K .* qᵗ';\n```\n:::\n\n\nThe landscape matrix $\\mathbf{M}$ can be summarized either through summation or Eigenanalysis, both can be used to quantify the functionality of a pixel as a source or as a target. The next section demonstrates Eigenanalysis, we first look at summation to summarize $\\mathbf{M}$. By summing over all rows, we get how well suitable target habitat is connected to suitable sources:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nfuncᵗ = vec(sum(M, dims=1)); #sum over rows\nConScape.plot_values(g, funcᵗ, title=\"Functional habitat\", color=cgrad(:viridis))\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![Habitat functionality of each pixel as a target (i.e. in receiving suitable habitat from sources).](nbk_functionality_variants_files/figure-html/fig-target_functionality-output-1.svg){#fig-target_functionality}\n:::\n:::\n\n\nSimilarly, by summing over all columns, we quantify how well suitable source habitat is connected to suitable target habitat:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nfuncˢ = vec(sum(M, dims=2)); #sum over columns\nConScape.plot_values(g, funcˢ, title=\"Functional habitat\", color=cgrad(:viridis))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![Habitat functionality of each pixel as a source (i.e. in contributing suitable habitat to targets).](nbk_functionality_variants_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\nWe could then multiply the functionality of a pixel as a source and as a target to identify pixels that are simultaneously functional as source and target.\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nfunc_tot = funcˢ .* funcᵗ;\n```\n:::\n\n\nNote that this last computation is only possible, if func$^s$ and func$^t$ are of the same length. In other words, the the target qualities cannot be represented as a sparse matrix (see Van Moorter et al. 2022 and Notebook [performance](/notebooks/nbk_landmarks.qmd)\n for more details).\n\nConScape's convenience function focuses on the 'source functionality' to allow for the usage of the sparse matrix representation of target qualities, which allows the computation of these metrics on even larger landscapes (see Notebook [performance](/notebooks/nbk_landmarks.qmd)\n for explanation):\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunc = ConScape.connected_habitat(h, connectivity_function=\n    ConScape.expected_cost, distance_transformation=x -> exp(-x/2000));\nConScape.heatmap(func, yflip=true, color=cgrad(:viridis), title=\"Functional habitat\")\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![Habitat functionality of each pixel as a target using ConScape's convenience function.](nbk_functionality_variants_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\nis identical to the one in Fig. [@fig-target_functionality].\n\n## Functionality: RSP expected cost with eigenanalysis\n\nIn addition to summarizing the landscape matrix $\\mathbf{M}$ through summation, we can also use Eigenanalysis:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nvˡ, λ, vʳ= ConScape.eigmax(h, connectivity_function=\n    ConScape.expected_cost, distance_transformation=x -> exp(-x/2000))\n\nvʳ = real.(vʳ)\nvˡ = real.(vˡ);\n```\n:::\n\n\nWhere $\\lambda$ corresponds to the 'metapopulation capacity' in metapopulation ecology ([@hanski2000metapopulation]):\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nλ\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n354.16197335389097\n```\n:::\n:::\n\n\nThe interpretation of this value outside the context of metapopulation theory still needs to be addressed in future research.\n\nThe right Eigenvector corresponds to the reproductive value, which is analogous to the functionality as a source: \n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nConScape.plot_values(g, vʳ, title=\"Reproductive value\", color=cgrad(:viridis))\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![Habitat functionality based on eigenanalysis of each pixel as a target (i.e. the reproductive value).](nbk_functionality_variants_files/figure-html/cell-17-output-1.svg){}\n:::\n:::\n\n\nNote that the landscape matrix $\\mathbf{M}^{st}$ is transposed compared to (e.g. [@ovaskainen2003much]) and therefore the right and left Eigenvectors switched interpretation.\n\nThe left Eigenvector then corresponds to the stable distribution, which is somewhat analogous to the functionality as a target:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nConScape.plot_values(g, vˡ, title=\"Stable distribution\", color=cgrad(:viridis))\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n![Habitat functionality based on eigenanalysis of each pixel as a source (i.e. the stable distribution).](nbk_functionality_variants_files/figure-html/cell-18-output-1.svg){}\n:::\n:::\n\n\nJust as [@ovaskainen2003habitat] we can multiply the left and right Eigenvectors:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\neigenvec = vˡ .* vʳ;\n```\n:::\n\n\nAn important note, Eigenanalysis requires the landscape matrix $\\mathbf{M}^{st}$ to be square, hence the sparse matrix representation of the target qualities is not possible (see main text and Notebook [performance](/notebooks/nbk_landmarks.qmd) for more details). Hence, we cannot rely on the 'landmark' approach to reduce the computational demands, which currently limits this type of eigenanalysis to relatively coarse landscape representations. \n\n## Functionality: survival probability with summation\n\nSee also Notebook [ecological distance](/notebooks/nbk_distance_metrics.qmd) for more details on the different distance and proximity metrics that can be used. We now demonstrate the use of the survival probability as an alternative metric to compute the amount of suitable target habitat that is functionally connected to a suitable source pixel:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nfunc_surv = ConScape.connected_habitat(h,\n        connectivity_function=ConScape.survival_probability);\nConScape.heatmap(func_surv, yflip=true, title=\"Habitat functionality\", color=cgrad(:viridis))\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![Habitat functionality based on survival probability.](nbk_functionality_variants_files/figure-html/cell-20-output-1.svg){}\n:::\n:::\n\n\nSee Notebook [dispersal mortality](/notebooks/nbk_cost.qmd) for more details on the use of mortality data as the basis for survival connectivity.\n\n\n## Functionality: least-cost distance with summation\n\nOur final demonstration to quantify the amount of connected habitat is related to the 'probability of connectivity' [@saura2007new] and the 'cost-benefit analysis' ([@drielsma2007raster],[@drielsma2007spatial]). These approaches both are built from the least-cost distance between source and target pixels. Although the RSP expected cost in theory includes the least-cost distance for $\\theta \\rightarrow \\infty$, it is not an efficient algorithm to use for least-cost based distances. We therefore implemented convenience functions to use Julia's implementation of the Dijkstra algorithm to compute the least-cost distance:\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nfunc_lc = ConScape.connected_habitat(g, connectivity_function=\n    ConScape.least_cost_distance, distance_transformation=x -> exp(-x/40));\n```\n:::\n\n\nThe 'connectivity of a landscape' from ([@drielsma2007spatial]) is then the sum of all elements in the landscape matrix $\\mathbf{M}^{st}$:\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nCL=sum(filter(x -> !isnan(x), func_lc))\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n518459.3477832595\n```\n:::\n:::\n\n\nAnd the 'probability of connectivity' further divides this 'connectivity of the landscape' by the squared area of the landscape ([@saura2007new]):\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nPC=CL/sum(map(x -> isnan(x) ? 0 : 1, func_lc))^2\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0.01814760383958709\n```\n:::\n:::\n\n\nIn addition, as above we can compute the source and target functionalities using the least-cost distance by respectively summing over all columns or all rows of the landscape matrix $\\mathbf{M}^{st}$, this corresponds to the colonization potential in [@drielsma2007raster]: \n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\nConScape.heatmap(func_lc, yflip=true, title=\"Colonization potential\", color=cgrad(:viridis))\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n![Habitat functionality based on the least-cost distance, which corresponds to the 'colonization potential' in [@drielsma2007raster].](nbk_functionality_variants_files/figure-html/cell-24-output-1.svg){}\n:::\n:::\n\n\n## Summary\n\nConScape allows for several different 'habitat functionality' metrics by combining different distance or proximity metrics to quantify the connectivity between sources and targets with different ways of summarizing across sources and/or targets. Theoretically, the RSP expected cost is a generalized version of the least-cost distance (i.e. RSP expected cost equals the least-cost distance for $\\theta \\rightarrow \\infty$), although numerical issues with the current algorithms prevent the usage of the RSP expected cost to replace the least-cost distance in actual applications. In addition to the RSP expected cost (and least-cost distance), ConScape also offers the survival probability to quantify the connectivity between source and target pixels. Two summary statistics have been proposed to quantify habitat functionality: summation and eigenanalysis. Summation was first proposed in [@hanski1999metapopulation] with the 'neighborhood habitat area index', whereas [@hanski2000metapopulation] proposed eigenanalysis to quantify the 'metapopulation capacity' for metapopulation persistence. Both of these approaches have been implemented in ConScape, however, the computational requirements for eigenanalysis may prevent this approach on large landscapes.  \n\n",
    "supporting": [
      "nbk_functionality_variants_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}