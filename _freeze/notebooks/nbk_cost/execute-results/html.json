{
  "hash": "6aaad6496f24cf3ae2aa13e57fd30412",
  "result": {
    "markdown": "---\ntitle: \"Dispersal mortality\"\nbibliography: biblio.bib\n---\n\n::: {.callout-tip}\n## Here you will learn\n\nIn this notebook, we demonstrate the possibility to use independent movement probablities and costs, similar to [@fletcher2019towards] and [@marx2020samc].  \n:::\n\n# Demonstration of independent likelihood and cost of movement\n\n\nIn this notebook, we demonstrate the possibility to use independent movement probablities and costs, similar to [@fletcher2019towards] and [@marx2020samc].  \n\n\n## Preamble\n\nSee notebook [Getting Started](/notebooks/nbk_getting_started.qmd) for a 'basic workflow' to learn about the fundamentals on data import and the creation of a ConScape `Grid`:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n#using Pkg\n#Pkg.activate(joinpath(ENV[\"HOME\"], \".julia\", \"dev\", \"ConScape\"))\n\nusing ConScape\nusing SparseArrays\nusing Statistics\nusing Plots\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ndatadir = joinpath(ENV[\"HOME\"], \"Downloads\", \"input_maps\")\noutdir = joinpath(ENV[\"TMPDIR\"], \"figures\")\nif !isdir(outdir)\n    mkdir(outdir)\nend\n```\n:::\n\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n\"C:/Users/bram.van.moorter/Documents/ConScape_website/site/notebooks/data/\"\n```\n:::\n:::\n\n\nWe use the data provided in [@marx2020samc]:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nmov_prob, meta_p = ConScape.readasc(joinpath(datadir, \n            \"prob_panther_cropped.asc\"))\nhab_qual, meta_q = ConScape.readasc(joinpath(datadir, \n            \"prob_panther_cropped.asc\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n([0.111111111938953 0.5 … 0.111111111938953 0.16666667163372; 0.125 0.125 … 0.111111111938953 0.16666667163372; … ; NaN NaN … 1.0 0.111111111938953; NaN NaN … 1.0 0.333333343267441], Dict{Any, Any}(\"cellsize\" => 500.0, \"nrows\" => 99, \"nodata_value\" => -999, \"ncols\" => 174, \"xllcorner\" => 615138.0, \"yllcorner\" => 257108.0))\n```\n:::\n:::\n\n\nNote, we did not have quality data for each pixel, for this demonstration we simply assumed that the permeability adequately represents quality (see Notebook [Getting Started](/notebooks/nbk_getting_started.qmd) for a better example with independent quality data).\n\nWe remove negative values:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nmov_prob = max.(0, mov_prob)\nhab_qual = max.(0, hab_qual);\n```\n:::\n\n\n## Cost data\n\nIn addition to the data on the habitat quality and the likelihood of movement, we also have independent data on the cost of movement ([@marx2020samc]):\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nmov_cost, meta_c = ConScape.readasc(joinpath(datadir, \n            \"mort_panther_cropped.asc\"))\nmov_cost = max.(0, mov_cost);\n```\n:::\n\n\nAs discussed in vanmoorter2021defining, to use the mortality risk as a cost in the RSP framework, we need to define the cost as the negative logarithm of the survival probability between adjacent pixels: \n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nmov_cost = -log.(1 .- mov_cost);\n```\n:::\n\n\nWe create the `Grid` by using these cost data, instead of a transformation from the likelihood of movement:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\ng = ConScape.Grid(size(mov_prob)...,\n    affinities=ConScape.graph_matrix_from_raster(mov_prob),\n    qualities=hab_qual,\n    costs=ConScape.graph_matrix_from_raster(mov_cost));\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n┌ Info: cost graph contains 15 strongly connected subgraphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:215\n┌ Info: removing 14 nodes from affinity and cost graphs\n└ @ ConScape C:\\Users\\bram.van.moorter\\.julia\\packages\\ConScape\\spkWs\\src\\grid.jl:225\n```\n:::\n:::\n\n\nTo visualize the movement costs, we define the following function, similar to the `plot_indegrees` function we used earlier (see Notebook [Getting Started](/notebooks/nbk_getting_started.qmd)):\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nfunction plot_incost(g; kwargs...)\n    values = sum(g.costmatrix, dims=1)\n    canvas = zeros(g.nrows, g.ncols)\n    for (i,v) in enumerate(values)\n        canvas[g.id_to_grid_coordinate_list[i]] = v\n    end\n    heatmap(canvas, yflip=true, axis=nothing, border=:none; kwargs...)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nplot_incost (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nplot_incost(g, title=\"Mortality risk\")\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](nbk_cost_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\n## Computing the survival probability\n\nNow we can compute the `GridRSP`:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nh = ConScape.GridRSP(g, θ=1.0);\n```\n:::\n\n\nNote that to compute the survival probability from $s$ to $t$ corresponding to the mortality cost associated to edges $(i,j)$, we need to set $\\theta=1.0$ ([@vanmoorter2021defining]).\n\nThe survival probability from all source pixels to a target pixel (e.g. 15000) is:\n\n::: {.cell layout-ncol='2' execution_count=12}\n``` {.julia .cell-code}\ntmp = zeros(17212)\ntmp[15000] = 1\n\ndisplay(ConScape.plot_values(g, tmp, title=\"Target\"))\n\nsurv = ConScape.survival_probability(h);\ndisplay(ConScape.plot_values(g, map(t -> t==1 ? NaN : t,  surv[:,15000]), title=\"Survival probability\"))\n```\n\n::: {.cell-output .cell-output-display}\n![a](nbk_cost_files/figure-html/cell-13-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display}\n![b](nbk_cost_files/figure-html/cell-13-output-2.svg){}\n:::\n\nSurvival probability to a target.\n:::\n\n\nFinally, we can use these survival probabilities to compute for each pixel the amount of habitat it is functionally connected to:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nfunc = ConScape.connected_habitat(h, \n            connectivity_function=ConScape.survival_probability);\nConScape.heatmap(Array(func), yflip=true, title=\"Functional habitat\")\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![Amount of connected habitat based on survival connectivity.](nbk_cost_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\n## Summary\n\nThe ConScape library allows users to define the cost of movement between adjacent pixels both as a transformation from the likelihood of movement, but also from independent cost data. This application is very useful to model dispersal with mortality ([@fletcher2019towards]), but could also be applied in combination with 'energy landscapes' discussed in: [@vanmoorter2021defining]. \n\n",
    "supporting": [
      "nbk_cost_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}